Thank you to InRhythm teammatesÂ Mike Fisher and Khaled Mohamed for their invaluable contribution to this article.

Managing a gradual, staged transition from Angular 1 to Angular 2 or React is not a pipe dream. Upgrading does not have toÂ mean a full rewrite, nor a significantÂ disruption to the release cycle. Although the risk canÂ be high, youâ€™re probably reading this article because you know the transition is worth it for the superior performance and smaller bundle sizesÂ of the next generation frameworks.

Additional motivation toÂ upgrade might be as a justificationÂ to ditch theÂ old Gulp/Bower build process forÂ Webpack 2 + ES6 Modules in all its tree-shaking gloryâ€¦ or even because it has become difficult to hire and retain top talent when engineersÂ donâ€™t want to work on legacy Angular 1 products (you did see the SO developer survey, right?).

Fortunately, there is a simple migration path that can be pursued in threeÂ discrete, meaningful and low-risk steps.

Each of above steps will move you tangibly closer to Angular 2 or React and provide real value and flexibility along the way. I hope to prove to you that the processÂ is achievableÂ incrementally, without significantly disrupting theÂ release cycle.

This post assumes that you are already familiar with modern build toolsÂ like Webpack, Rollup or Browserify and aware of the benefits of upgrading to Angular 2 or React. As such, Iâ€™m not going to dive into Webpack configurationsÂ nor into the specifics of next-generation frameworks. Instead, Iâ€™ll focus on how to sequence the transitionÂ in order to minimize disruption to your release schedule.

If youâ€™re working with a legacy Angular 1 codebase, thereâ€™s a decent chance that theÂ starting point was John Papaâ€™s famousÂ generator-hottowel. Iâ€™m going to start with a freshly generated hottowel project to demonstrateÂ the migration.

Hottowel uses a combination of IIFEs, Gulp, Bower, wiredep, and gulp-useref to readÂ and concatenate the source files into an application bundle. Itâ€™s a brilliant pattern that leverages theÂ Bower dependency tree and Angularâ€™s module system and dependency injection to correctly buildÂ your application. ItÂ works incrediblyÂ well, but it in 2017 is showing itâ€™s age. The lack of a proper bundler means that recent, game changing developments likeÂ native JavaScript modules,Â improvements to IDE tooling,Â tree shaking, live-refresh/hot-module-reloading, andÂ CSS modulesÂ are almost impossible to support. Furthermore, Angular 2 and React presuppose the use of a bundler. To move forward, youâ€™ll have to ditch your old gulpfile.

Amazingly, youÂ do not need to modify your existing source code to transition to Webpack. You simply need to create an application entry point and add an index.js file in each subdirectory of your application to require all of your source files.

For example,Â this is the directory structure that hottowel generates:

First, create a fileÂ  Â with the following contents:

This file is the entry point to your build process. It represents the root of the tree thatÂ comprises your application. InsideÂ  Â andÂ  Â  and every other subdirectory there is anÂ  Â file which will importÂ all of the source code in the sameÂ directory in addition to any subdirectories.

For example,Â  Â will look like this:

and which contains three subdirectories and no files should look like this:

When complete, a chain of files andÂ  Â statements will link your entire application. By pointing Webpack at it can generateÂ your entire application bundle. The directory structure should now look like this, with an in , Â and in every other subdirectory under :

If itâ€™s unclear how this pattern works, I recommend reading up on module loaders and these resourcesÂ on ES6 and Node/CommonJS module resolution.

Now that your bundler is in place, you can begin to strip away some of the cruft necessitated byÂ simply concatenating source files. As an example, letâ€™s take a look at the AdminController at .

Immediately, there are a few things we can do. First, we can remove the wrapping IIFE since Webpack will package each file in its own closure. We can also remove â€˜use strictâ€™ because ES6 modules are executed in strict mode by default. Letâ€™s also import because we want to be explicit about the dependencies ofÂ every file. Importing 3rd party libraries instead of treating them as globals allows Webpack to extract them into a vendor or commons bundle on which you can set appropriate caching headers, potentially saving returning users hundreds of kilobytes of downloaded content and multiple network calls.

After these changesÂ  should now look like this:

Next, we want to convert the services and controller to ES6 classes. Both React and Angular 2 encourage implementingÂ application components withÂ ES6 classes. If youâ€™re unfamiliar with ES6 classes, I highly recommend reading up on them and on prototypal inheritance in JavaScript in general. As an ES6 class, looks like this:

There are a few subtleÂ patterns to recognize here. First, we ditched the annotation in favor of a static class property.

Second, there is no private scope. WithÂ ES6 classes, all membersÂ are public (for now). The body of an ES6 class can only containÂ static and prototypeÂ property declarations. This means that the initialization logic in the body of the function needs to be moved into the constructor or into the new Â lifecycle method introduced in Angular 1.5.

* Technically, to take advantage of lifecycle methods we need to convertÂ this controller into a component. Take a lookÂ at Todd Mottos upgrade guides to familiarize yourself with the new patterns and for tips on easing the transition to Angular 2.

Finally, Â  , also known as â€œcontroller asâ€ syntax has been eliminated. Instance and prototype properties and methods are accessible on Â so we donâ€™t need that workaround anymore.Â This is a mixed blessing because Â helped us avoid JavaScriptâ€™s notoriously confusing rules about resolving . When you refactor to a class youâ€™ll need to decide on a pattern for how to keep this proper Â in scope. Concepts to investigate include arrow functions (lexical scoping of ), binding prototype methods to the instanceÂ in the constructor, class property initializers, andÂ the proposedÂ bind operator .

Take your time as you refactor your services and controllers into classes and your directives into componentsâ€“you donâ€™t have to do this all at once. In fact, you can write new code with the new patterns and leave your old code alone if itâ€™s working just fine. The point of Step 1Â wasÂ to giveÂ you the flexibility to refactorÂ at your own pace.

If youâ€™ve made it this far, your formerly legacy codebase is starting to look a little more fresh. You now have a proper build process and you can tell prospective hires thatÂ yes, your company uses the latest ES6 featuresÂ ğŸ˜‰.

The final step is to decoupleÂ your source code as much as possible from the framework. This can also be done incrementally, file-by-file as time permits.

Utilizing the following patterns will breathe new life into your legacyÂ application while setting the stage for an eventualÂ migration to the framework of your choosing. By the end, you might find that you donâ€™t need to switch frameworks at all!

If youâ€™re serious about making the transition to Angular 2, thenÂ thoroughly readÂ the official upgrade guideÂ and consider developing a hybrid application if you really canâ€™t afford the risk of a hard cutover.

Of all the recommendations above, the ui-router pattern for eliminating the Angular module system might be the least familiar, though Iâ€™ve found it essential for easing the migration away from Angular 1.

The ui-router team put together an amazing sample application that shows off the power of their library along with demonstrating beautifully how to build a modern, modular application. One thing it illustratesÂ admirably is how to abstract the Angular wiring into a single file in the application.

Currently, every file in our example application is still tightly coupledÂ to Angular because they containÂ this little preamble or something like it:

This repetition justÂ feels wrongÂ whenÂ Donâ€™t Repeat Yourself is a programmerâ€™sÂ mantra. To DRY up this anti-pattern, the ui-router team followed a three-pronged strategy:

Applying this to our sample hottowel application, weâ€™llÂ modify Â to create the single Angular module and expose the helper function that handles registering application componentsÂ with the .

After completing step 2, should look like this:

After applying the ui-router refactor, Â now looks like this:

The export Â is our single applicationÂ module. ,Â  , etc. are gone. In their place we will attach every provider to Â via the Â function.

is how we wire up the Angular application. It accepts two arguments, an Angular module and an object describing a mini-library composed of ui-router state definitions, services, factories, controllers, etc. When invoked, Â will iterate through each collection and dictionary, registering the providers within on the module. Any class, object or function that we want to expose as an injectable in our Angular app we can wire up with via . With this framework in place, we can remove the Angular preamble from the beginning of every file.

Letâ€™s see how this can be applied to , converting it from an Angular module to a mini-library.

Before, Â and look like this:

After the refactor,Â they look like this:

When we invoke it will register the admin moduleâ€™s components on the main module. Applying this pattern to the rest of the project, we have now removed the Angular wiring from nearly every file in the application! Our source codeÂ is nearly clear of coupling to the framework and itâ€™s in much better shape that when we started out.

It would be easy to mistake the refactored Â for something thatâ€™s not Angular 1. With mostÂ of the framework ceremony stripped away, itâ€™sÂ clear that we could quickly factorÂ  Â into a React component that expectsÂ a Â prop and whose Â method returns the template from .

If you decided opted to replace inheritance andÂ  Â with ngRedux then moving to React becomes a task thatâ€™s more tedious than complex. You can also look intoÂ ngUpgradeÂ which supports loading hybrid ng1/ng2 applications, giving you even more granular control over how you fully leave Angular 1.

TypeScript can be a game changer, eliminating whole classes of errors that generally arenâ€™t diagnosable until runtime with plain JavaScript. If youâ€™re unfamiliar with statically typed languages and the benefits thereof, I recommend starting with the TypeScript documentation to see how it can make your projects more resilient.

An incremental transition to TypeScript is simple with a Webpack build process. First, change the extension of any file that you want to write inÂ TypeScript to Â and then addÂ ts-loader to your Webpack config, configured to resolve and transpile files with aÂ  Â extension. Since TypeScript is a superset of JavaScript you can mix and match as you please.

Below are links to articles and repositories which you might find helpful when planning your upgrade. PleaseÂ post any helpful articles or migration advice in the comments.|||

Managing a gradual, staged transition from Angular 1 to Angular 2 or React is not a pipe dream. Upgrading does not have to mean a full rewrite, nor a ...