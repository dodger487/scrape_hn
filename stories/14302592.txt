Lush is an object-oriented programming language designed for researchers, experimenters, and engineers interested in large-scale numerical and graphic applications. Lush is designed to be used in situations where one would want to combine the flexibility of a high-level, weakly-typed interpreted language, with the efficiency of a strongly-typed, natively-compiled language, and with the easy integration of code written in C, C++, or other languages. Lush is andesigned for researchers, experimenters, and engineers interested in. Lush is designed to be used in situations where one would want to combine the flexibility of a high-level, weakly-typed interpreted language, with the efficiency of a strongly-typed, natively-compiled language, and with the easy integration of code written in C, C++, or other languages. Lush is Free Software (under the GPL license) and runs on GNU/Linux, Solaris, Irix, and Windows under Cygwin. Lush can be used advantageously for projects where one would otherwise use a combination of an interpreted language like Matlab, Python, Perl, S+, or even (gasp!) BASIC, and a compiled language like C. Lush brings the best of both worlds by wrapping three languages into one: (1) a weakly-typed, garbage-collected, dynamically scoped, interpreted language with a simple Lisp-like syntax, (2) a strongly-typed, lexically-scoped compiled language that uses the same Lisp-like syntax, and (3) the C language, which can be freely mixed with Lush code within a single program, even within a single function. It sounds complicated, but it is not. In fact, Lush is designed to be very simple to learn and easy to use. If you do research and development in signal processing, image processing, machine learning, computer vision, bio-informatics, data mining, statistics, simulation, optimization, or artificial intelligence, and feel limited by Matlab and other existing tools, Lush is for you. If you want a simple environment to experiment with graphics, video, and sounds, Lush is for you. A very clean, simple, and easy to learn Lisp-like syntax. A compiler that produces very efficient C code and relies on the C compiler to produce efficient native code (no inefficient bytecode or virtual machine). An easy way to interface C functions and libraries, and a powerful dynamic linker/loader for object files or libraries (.o, .a and .so files) written in other compiled languages. The ability to freely mix Lisp and C in a single function. A huge library of over 10,000 numerical routines, including full interfaces to GSL, LAPACK, and BLAS. An extensive set of graphic routines, including an object-oriented GUI toolkit, an interface to OpenGL/GLU/GLUT, and the OpenInventor scene rendering engine. An interface to the Simple Directmedia Layer (SDL) multimedia library, including a sprite class with pixel-accurate collision detection (perfect for 2D games). Sound and video grabbing (using ALSA and Video4Linux). bindings to the JavaVM API and to the Python C API. This combination of flexibility, efficiency, and extensive libraries with over 14,000 functions and classes makes Lush an ideal platform for research and development in signal processing, image processing, machine learning, computer vision, bio-informatics, data mining, statistics, and artificial intelligence. Its speed and extensive libraries allow such things as real-time sound, image, and video processing. Most users use Lush as a research tool, but many use it as a general purpose script language, or as a general language for application development. Some have been known to use Lush to develop 2D and 3D games. A few have even used Lush to develop commercial software for embedded processors. This combination of flexibility, efficiency, and extensive libraries with over 14,000 functions and classes makes Lush an ideal platform for research and development in signal processing, image processing, machine learning, computer vision, bio-informatics, data mining, statistics, and artificial intelligence. Its speed and extensive libraries allow such things as real-time sound, image, and video processing. Most users use Lush as a research tool, but many use it as a general purpose script language, or as a general language for application development. Some have been known to use Lush to develop 2D and 3D games. A few have even used Lush to develop commercial software for embedded processors. For more specific information, have a look at this tutorial. 2009-10-19: A first Lush 2.0 beta is out! 2007-01-05: Our warmest thanks go to Yaroslav Halchenko who has taken over the maintenance of the Debian package for Lush. 2005-01-18: A version of Lush compiled for the Sharp Zaurus is available here (no X-window and no dynamic loader support). Our thanks go to Michael Neuroth. IMPORTANT NOTE: New features and fixes are being added to the CVS version of Lush on a daily basis. Before reporting a problem, please install the CVS version. Installation of the Debian/Ubuntu Package: As of December 2006, the maintainer of the Debian package for Lush is Yaroslav Halchenko (many thanks to Yaroslav for volunteering). Until Yaroslav's recent involvement, the Debian package was missing a few important dependencies. Yaroslav has fixed them, so it should become considerably easier to install Lush on Debian/Ubuntu and their many variations. Unfortunately, the Lush version on Ubuntu 6.10 "Edgy" is still 1.1, and has many package dependencies missing. So, until the next version, get the CVS version (see below) or download and build the latest released version. Other Linux Distros: many commercial Linux distros (Mandriva, Red Hat, Fedore Core, SuSE) have pre-packaged versions of Lush. However, we strongly recommend that you install and compile the CVS version if you are a serious user. CVS snapshot: if you want the bleeding edge version, you can get a CVS snapshot as follows: cvs -d:pserver:anonymous@lush.cvs.sourceforge.net:/cvsroot/lush login [type enter when prompted for a password] cvs -z3 -d:pserver:anonymous@lush.cvs.sourceforge.net:/cvsroot/lush co lush You can subsequently synchronize to the latest CVS version with Released version: go to the download page, download the latest version, and unpack the tar.gz 

 Pre-requisites: On Debian/Ubuntu, you must install the following packages: gcc, g++, libx11-dev, libinutils-dev, indent, libreadline5, libreadline5-dev libgsl0, libgsl0-dev. On other distros (Mandriva, SuSE, Fedora Core, etc), there are corresponding packages with slightly different names. Optional pre-requisites: Optionally, you can also install the OpenGL development packages (freeglut3, freeglut3-dev, libgl1-mesa-dev), SDL development packages (libsdl1.2debian, libsdl1.2-dev), and BLAS/LAPACK (lapack3, lapack3-dev). You can run Lush directly by typing wherever-you-installed-lush/bin/lush, or by adding wherever-you-installed-lush/bin to your shell path. However, you can also perform a system-wide install as follows: or (on Ubuntu): This will install Lush and its libraries in /usr/local/share/lush and the executable in /usr/local/bin/lush with a link from /usr/bin/lush. 

 To start Lush, type "lush" at the prompt (and CTRL-D to exit). Emacs users will prefer to run Lush within Emacs. To do so, add the following line to your .emacs file: Then type "ALT-X lush" in Emacs to start Lush. At the Lush prompt, type (helptool) to fire up the documentation browser. NOTE:: on the old Mandrake 9.2, change the "-O3" to "-O2" in the lush/src/Makefile or Lush may crash (due to some bug in gcc). two languages: an efficient compiled language such as C or C++ for implementing the low-level or computationally expensive function, and a flexible, possibly interpreted language for high-level control, scripting, experimentation, and tinkering. Popular research-oriented interpreters such as Matlab are somewhat inefficient, lack support for complex data structures, lack the power of a full-fledged object-oriented programming language, and lack simple interfacing to C and other compiled languages. Many software projects, particularly research projects, require: an efficient compiled language such as C or C++ for implementing the low-level or computationally expensive function, and a flexible, possibly interpreted language for high-level control, scripting, experimentation, and tinkering. Popular research-oriented interpreters such as Matlab are somewhat inefficient, lack support for complex data structures, lack the power of a full-fledged object-oriented programming language, and lack simple interfacing to C and other compiled languages. Lush uses a very simple Lisp syntax. If the word "Lisp" sends shivers down your spine, be advised that the dialect of Lisp that Lush implements is extremely simple to learn, with possibly one the simplest syntaxes around. Most scientists, engineers, and software developers who have learned Lush have become proficient at it in a few days, even if they had no prior exposure to Lisp. It's very simple. Really. In fact, Lush has been used to teach programming to kids. The Lush compiler has several interesting properties, and a few limitations. Its main advantage is that it generates very efficient C code which is then compiled with the best available C compiler for the machine considered and loaded dynamically. The C code produced does not simulate a virtual machine, it is real, low-level, bang-the-metal, no-runtime-check, don't-break-for-animals, C code, just like what you would write by hand. Its main disadvantage is that, although it compiles a Lisp-like language, it does no more for you than what a C compiler would (no automagic memory management, no garbage collection, no functional programming). The Lush interpreter is written in C and features all the usual functionalities and constructs found in every decent object-oriented programming language such as conditional statements, loops, local variables, functions, macros, objects, classes, methods, and inheritance, but it also provides a large number of functions for manipulating lists, strings, vectors, matrices, and tensors. String functions include such things as regular expression matching and substitutions. This shows a simple lunar lander game that uses the SDL library and the sprite class. The whole game fits in 60 lines of Lush. The Lush interpreter is quite similar to some lisps of the mid 80's like "Le_Lisp" and "UCI-Lisp". It is significantly simpler than "Common Lisp" and quite different from Scheme. The Lush interpreter is quite similar to some lisps of the mid 80's like "Le_Lisp" and "UCI-Lisp". It is significantly simpler than "Common Lisp" and quite different from Scheme. An unusual feature of Lush is its compiler to C, its dynamic linker/loader, and the ease with which one can interface existing C functions and libraries. En even more unusual feature is the ability to intermix Lisp and C source code within a single function. The vector and matrix manipulation engine is quite powerful and efficient, making Lush ideal for heavy numerical applications and applications such as signal and image processing. It includes functions to create, resize, and convert vectors, matrices, and tensors with up to eight dimensions. It also includes basic matrix operations such as scalar operations on all elements of a matrix, dot products, outer products, transposition, highly optimized 1D and 2D convolutions. A set of vector/matrix iterators is also provided. Lush is an object-oriented language. Classes with slots and methods can be defined and compiled. Derived classes inherit the slots and methods of their parent class (similar to the C++ semantics). Lush includes all the functions familiar to Lisp aficionados, such as list functions, list iterators, physical list manipulation, macros, splicing macros, symbol manipulation, etc, but most casual users will probably prefer to stay away from those. Lush provides a set of simple-to-use low-level graphic functions to draw lines, polygons, rectangles, pictures, and text in color, with automatic refresh and double-buffering capability (for simple animations). Graphics can be drawn in an X-windows window (on Unix), or sent to a PostScript file. Lush also contains a very compact and easy-to-use object-oriented graphical user interface generator called ``Ogre''. Ogre is entirely written in Lisp on top of the low-level graphic functions mentioned above. It contains predefined classes for buttons, sliders, radio buttons, menus, string editors, etc... Ogre includes an automatic mechanism for placing objects in the window, thereby greatly simplifying the design and implementation of GUIs. Simple GUIs can be written in extremely short times and are very compact. A very unique feature is that there is no need to call an "event main loop": you can keep typing at the Lush prompt while your GUI app is running! Lush provides two models for Input/Output. One is a set of ``Lispy'' I/O functions that allow easy input and output of ASCII data, lisp expressions, lisp objects, and matrices. It includes such goodies as pipes and sockets. The other model essentially provides access to the standard C I/O library, including fopen, popen, fprintf, fscanf, fgetc, fputc fgets, and various functions for reading and writing matrices. Large matrices can be mapped in the virtual addressing space, instead of explicitely loaded in memory. This allows to access very large datasets efficiently. This picture shows Lush's on-line documentation GUI. The right pane shows an example of function that integrates Lush and C in the same source. The C segment (shown in green) is delimited by the hash-brace characters. Lisp variables can be refered to from the C by prepending a dollar sign. Click on the picture for a full page screenshot. 

 Lush has a huge collection of libraries and utilities available to the user. Some are written in Lisp, some are written in C and interfaced to Lush, others are pre-existing libraries that have been interfaced to Lush. For our numerically enclined friends, Lush has a full interface to the GNU Scientific Library (GSL, 3500 function), and to the LAPACK and BLAS Linear Algebra libraries. This gives access to an extensive set of numerical and statistical functions (several thousand in fact). Lush includes a full interface to the industry-standard OpenGL library that allows the creation of 3D graphics and animations. This interface include an interface to GLUT, OpenGLU, and (coming soon) OpenRM (scene graph rendering engine). This makes Lush an excellent platform to write interactive virtual reality applications, simulation software, and computer games. Another popular library interfaced to Lush is the multimedia and game API Simple Directmedia Layer (SDL). It is enhanced by a high-level library that allows the easy manipulation of sprites and animated, movable screen objects with pixel-accurate collision detection. This library, combined with Lush's simple syntax, makes it ideal for developing simple video games and for teaching programming to children. Lush contains a library of image processing functions to load, save, resize and resample, warp, filter, and analyze images. Mathematical morphology operations such as connected component analysis, distance transform, erosion, and dilation, are also available for bitonal images. It also includes classes and functions for easily grabbing video using the Video4Linux API. It also includes an interface to the Intel's Open Computer Vision library (OpenCV). Lush includes a library to manipulate probabilistic finite state machines and transducers. It allows the construction of grammars and finite state machine, and well as more advanced FSM algebra operations such as graph transduction, composition, and viterbi search algorithm. It also allows gradient-based training of systems that integrate such objects, as described in LeCun, Bottou, Bengio, Haffner: gradient-based learning applied to document recognition, Proc. IEEE, 86-11, 1998. Lush offers an extensive library for gradient-based machine learning (which is the main research interest of the authors of Lush). The list includes: neural networks (including convolutional neural networks), radial basis functions, support vector machines, and many others. This library is based on an innovative object-oriented design that allows to build large learning machines out of multiple learning modules and to train them cooperatively. Commercially used optical recognition systems have been built with this library. Lush also provides an interface to the popular Torch package which includes even more machine learning paradigms. In addition, Lush provides various interfaces to multimedia libraries, including Video4Linux (video grabbing) and ALSA (audio recording/playing/processing).  What's with all the frogs?

 Well, Yann LeCun and Leon Bottou are both French, and many of the past contributors have been French or French-speaking (Patrice Simard, Yoshua Bengio, Patrick Haffner, Pascal Vincent). Years of extensive focus groups studies and consultation with top marketing experts convinced us that using an escargot would send the wrong message for an allegedly fast language. Also, frogs are very good at catching bugs. Cute penguins and gnus were already taken, as well as the numerous species found on the covers of O'Reilly books. We like frogs. Really. Some of our best friends are frogs. Particularly those accompanied by garlic and butter.

 [No Frog was physically harmed in the making of this page, though we probably did hurt their feelings.]  I want to get started, is there a good tutorial on Lush?

 Have a look at this tutorial.  This site looks like a rip-off of the DjVuLibre site

 Lush and DjVu were produced by the same people (in fact Lush was used to prototype the first version of DjVu). So, no rip-off, just laziness. [This page is made entirely of recycled HTML tags]|||

Lush: the programming language for researchers