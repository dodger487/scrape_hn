Ruby 2.4.1 was released this week and included an upgrade to its underlying regular expression engine, Onigmo. The headline feature in this update was support for â€˜the absent operatorâ€™ but what is this and what is it for?

An issue on the Onigmo repository about the absent operator pointed to a 2007 Japanese academic paper [PDF] by Tanaka Akira that, to my delight, uses Ruby for its examples. Not being a reader of Japanese, I struggled to grasp the concept but it seemed to promise to provide developers with a new mechanism to more easily notate complex matches.

The next step towards an absent operator in Rubyâ€™s regular expressions system came 5 years ago in a suggestion for adding a â€˜negation flagâ€™. It was suggested that a flag could negate a regular expression. For example, would match anything that didnâ€™t.

This essentially â€˜negativeâ€™ regex feature has now appeared in the somewhat altered form of where matches any string that doesnâ€™t match . Note that this is not the same as a negative look-behind or look-aheadâ€Šâ€”â€Šweâ€™ll see how shortly.

Letâ€™s see the absent/absence operator in (very basic) action. If you have Ruby 2.4.1, you can follow along too!

Using can also be quite illuminating:

Hang on. It matches! If itâ€™s testing for absence of coffee (heaven forbid) why does it match? The clue is in the . If it were actually matching on â€œcoffeeâ€ itâ€™d be 0. Instead, is matching against â€œoffeeâ€ which is not â€œcoffeeâ€.

Note that this contrasts with how a negative look-behind works:

The negative look-behind results in a complete non-match for the whole regular expression because â€œcoffeeâ€ is present. The negative look-behind essentially looks to see if the specified expression is present and then fails if so. The absence operator, however, ensures that anything that isnâ€™t the specified expression will match.

We can see the same the other way around with look-aheads:

Here we have the same issue. The negative lookahead results in a non-match because â€˜tvâ€™ is present. With the absence operator, however, â€œtâ€ is technically not the same thing as â€œtvâ€ so we still get a match.

An anchor would, however, bring the behavior somewhat into line:

Thankfully it turns out some documentation has been created which presents perhaps a more useful example than the aboveâ€Šâ€”â€Šmatching complete old-style C comments:

This is correct, but it can be tricky to see why until you come to a situation where you need this level of control.

WhileÂ  is not greedy, if anchors are used itâ€™ll be as greedy as it needs to be if it helps it find a matchâ€Šâ€”â€Šit just wonâ€™t be any more greedy than that! This means the invalid comment gets matched in full when really you want to ensure the comment does not contain at all.

The absent operator, therefore, works in situations where you might want to get negative group-style behavior (so when will match a character that isnâ€™t ) but with a string of characters.

For example, what if we wanted to detect strings that do NOT contain ?

Or how about a rather convoluted example of matching any matching pairs of which are NOT separated by CRLF ( )?

So far so good. Letâ€™s now mix in some CRLFs:

I am hoping to come up with some better, more practical examples for a followup postâ€Šâ€”â€ŠI suspect there might be something around trivial HTML parsing (oh, yes, that old chestnut) that could show it off better, but for nowâ€¦

Iâ€™m hoping this post inspires people who are far more adept with regular expressions and their use cases than me to write something more useful, but for now, this is what weâ€™ve got. ğŸ˜ Enjoy!|||

Ruby 2.4.1 was released this week and included an upgrade to its underlying regular expression engine, Onigmo. The headline feature in this update was support for â€˜the absent operatorâ€™ but what isâ€¦