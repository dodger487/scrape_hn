This is the fourth draft of this document.

This code and text are dedicated to the public domain. You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

You may copy and paste any code here verbatim into your codebase, wiki, blog, book or Haskell musical production as you see fit. The Markdown and Haskell source is available on Github. Pull requests are always accepted for changes and additional content. This is a living document.

Sections that have had been added or seen large changes:

Cabal is the build system for Haskell.

For example, to install the parsec package to your system from Hackage, the upstream source of Haskell packages, invoke the command:

The usual build invocation for Haskell packages is the following:

To update the package index from Hackage, run:

A file will be created with the configuration options for our new project.

The latest feature of is the addition of Sandboxes, ( in cabal > 1.18 ) which are self contained environments of Haskell packages separate from the global package index stored in the of our project's root. To create a new for our project, run:

Additionally, the can be torn down:

When in the working directory of a project with a that has a configuration already set up, invoking commands alters the behaviour of cabal itself. For instance, the command will alter only the install to the local package index, not the global configuration.

To install the dependencies from the file into the newly created , run:

Dependencies can also be built in parallel by passing where is the number of concurrent builds.

Let's look at an example file. There are two main entry points that any package may provide: a and an . Multiple executables can be defined, but only one library. In addition, there is a special form of executable entry point , which defines an interface for invoking unit tests from .

For a library, the field in the file indicates which modules within the package structure will be publicly visible when the package is installed. These modules are the user-facing APIs that we wish to expose to downstream consumers.

For an executable, the field indicates the module that exports the function running the executable logic of the application. Every module in the package must be listed in one of , or fields.

To run an "executable" for a project under the :

To load the "library" into a GHCi shell under :

The metavariable is either one of the executable or library declarations in the file and can optionally be disambiguated by the prefix or respectively.

To build the package locally into the folder, execute the command:

To run the tests, our package must itself be reconfigured with the and the options. The must be installed manually, if not already present.

Moreover, arbitrary shell commands can be invoked with the GHC environmental variables set up for the . Quite common is to invoke a new shell with this command such that the and commands use the . ( They don't by default, which is a common source of frustration. ).

The haddock documentation can be generated for the local project by executing the command. The documentation will be built to the folder.

When we're finally ready to upload to Hackage ( presuming we have a Hackage account set up ), then we can build the tarball and upload with the following commands:

Sometimes you'd also like to add a library from a local project into a . In this case, run the command to bring the library into the from a local directory:

The current state of a can be frozen with all current package constraints enumerated:

This will create a file with the constraint set.

Using the and commands is preferable, but sometimes we'd like to manually perform their equivalents at the shell. Several useful aliases rely on shell directory expansion to find the package database in the current working directory and launch GHC with the appropriate flags:

There is also a zsh script to show the sandbox status of the current working directory in our shell:

The configuration is stored in and contains various options including credential information for Hackage upload. One addition to configuration is to completely disallow the installation of packages outside of sandboxes to prevent accidental collisions.

A library can also be compiled with runtime profiling information enabled. More on this is discussed in the section on Concurrency and Profiling.

Another common flag to enable is which forces the local build of Haddock documentation, which can be useful for offline reference. On a Linux filesystem these are built to the directory.

If GHC is currently installed, the documentation for the Prelude and Base libraries should be available at this local link:

Stack is a new approach to Haskell package structure that emerged in 2015. Instead of using a rolling build like , breaks up sets of packages into release blocks that guarantee internal compatibility between sets of packages. The package solver for uses a different, more robust strategy for resolving dependencies than has historically used.

For other operating systems, see the official install directions.

Once is installed, it is possible to setup a build environment on top of your existing project's file by running:

An example file for GHC 7.10.3 would look like:

Most of the common libraries used in everyday development are already in the Stackage repository. The field can be used to add Hackage dependencies that are not in the Stackage repository. They are specified by the package and the version key. For instance, the package could be added to the build:

The command can be used to install packages and executables into either the current build environment or the global environment. For example, the following command installs the executable for , a popular linting tool for Haskell, and places it in the PATH:

To check the set of dependencies, run:

Just as with , the build and debug process can be orchestrated using commands:

To visualize the dependency graph, use the dot command piped first into graphviz, then piped again into your favorite image viewer:

Enabling GHC compiler flags grants the user more control in detecting common code errors. The most frequently used flags are:

Like most compilers, GHC takes the flag to enable all warnings. However, a few of the enabled warnings are highly verbose. For example, and typically would not correspond to errors or failures.

Any of these flags can be added to the section of a project's file. For example:

The flags described above are simply the most useful. See the official reference for the complete set of GHC's supported flags.

For information on debugging GHC internals, see the commentary on GHC internals.

Hackage is the upstream source of Free and/or Open Source Haskell packages. With Haskell's continuing evolution, Hackage has become many things to developers, but there seem to be two dominant philosophies of uploaded libraries.

In the first philosophy, libraries exist as reliable, community-supported building blocks for constructing higher level functionality on top of a common, stable edifice. In development communities where this method is the dominant philosophy, the author(s) of libraries have written them as a means of packaging up their understanding of a problem domain so that others can build on their understanding and expertise.

In contrast to the previous method of packaging, a common philosophy in the Haskell community is that Hackage is a place to upload experimental libraries as a means of getting community feedback and making the code publicly available. Library author(s) often rationalize putting these kind of libraries up undocumented, often without indication of what the library actually does, by simply stating that they intend to tear the code down and rewrite it later. This approach unfortunately means a lot of Hackage namespace has become polluted with dead-end, bit-rotting code. Sometimes packages are also uploaded purely for internal use within an organisation, to accompany a paper, or just to integrate with the build system. These packages are often left undocumented as well.

For developers coming to Haskell from other language ecosystems that favor the former philsophy (e.g., Python, Javascript, Ruby), seeing thousands of libraries without the slightest hint of documentation or description of purpose can be unnerving. It is an open question whether the current cultural state of Hackage is sustainable in light of these philsophical differences.

Needless to say, there is a lot of very low-quality Haskell code and documentation out there today, so being conservative in library assessment is a necessary skill. That said, there are also quite a few phenomenal libraries on Hackage that are highly curated by many people.

As a general rule, if the Haddock documentation for the library does not have a minimal worked example, it is usually safe to assume that it is an RFC-style library and probably should be avoided in production-grade code.

Similarly, if the library predates the text library (released circa 2007), it probably should be avoided in production code. The way we write Haskell has changed drastically since the early days.

GHCi is the interactive shell for the GHC compiler. GHCi is where we will spend most of our time in every day development.

The introspection commands are an essential part of debugging and interacting with Haskell code:

Querying the current state of the global environment in the shell is also possible. For example, to view module-level bindings and types in GHCi, run:

To see compiler-level flags and pragmas, use:

Language extensions and compiler pragmas can be set at the prompt. See the Flag Reference for the vast collection of compiler flag options.

Several commands for the interactive shell have shortcuts:

The configuration for the GHCi shell can be customized globally by defining a in or in the current working directory as .

For example, we can add a command to use the Hoogle type search from within GHCi. First, install :

Then, we can enable the search functionality by adding a command to our :

For reasons of sexiness, it is desirable to set your GHC prompt to a or a . Only if you're into that lifestyle, though.

For large projects, GHCi with the default flags can use quite a bit of memory and take a long time to compile. To speed compilation by keeping artificats for compiled modules around, we can enable object code compilation instead of bytecode.

Enabling object code compliation may complicate type inference, since type information provided to the shell can sometimes be less informative than source-loaded code. This under specificity can result in breakage with some langauge extensions. In that case, you can temporarily reenable bytecode compilation on a per module basis with the flag.

If you all you need is to typecheck your code in the interactive shell, then disabling code generation entirely makes reloading code almost instantaneous:

Haskell has a variety of editor tools that can be used to provide interactive development feedback and functionality such as querying types of subexpressions, linting, type checking, and code completion.

Several prepackaged setups exist to expedite the process of setting up many of the programmer editors for Haskell development. In particular, using can remarkably improve programmer efficiency and productivity because the project attempts to implement features common to modern IDEs.

The bottom is a singular value that inhabits every type. When this value is evaluated, the semantics of Haskell no longer yield a meaningful value. In other words, further operations on the value cannot be defined in Haskell. A bottom value is usually written as the symbol âŠ¥, ( i.e. the compiler flipping you off ). Several ways exist to express bottoms in Haskell code.

For instance, is an easily called example of a bottom value. This function has type but lacks any type constraints in its type signature. Thus, is able to stand in for any type in a function body, allowing type checking to succeed, even if the function is incomplete or lacking a definition entirely. The function is extremely practical for debugging or to accommodate writing incomplete programs.

Another example of a bottom value comes from the evaluation of the function, which takes a and returns something that can be of any type. This property is quite similar to , which also can also stand in for any type.

Calling in a function causes the compiler to throw an exception, halt the program, and print the specified error message. In the function below, passing the function as the divisor results in this function results in such an exception.

A third type way to express a bottom is with an infinitely looping term:

Examples of actual Haskell code that use this looping syntax live in the source code of the GHC.Prim module. These bottoms exist because the operations cannot be defined in native Haskell. Such operations are baked into the compiler at a very low level. However, this module exists so that Haddock can generate documentation for these primitive operations, while the looping syntax serves as a placeholder for the actual implementation of the primops.

Perhaps the most common introduction to bottoms is writing a partial function that does not have exhaustive pattern matching defined. For example, the following code has non-exhaustive pattern matching because the expression, lacks a definition of what to do with a :

The code snippet above is translated into the following GHC Core output. The compiler inserts an exception to account for the non-exhaustive patterns:

GHC can be made more vocal about incomplete patterns using the and flags.

A similar situation can arise with records. Although constructing a record with missing fields is rarely useful, it is still possible.

When the developer omits a field's definition, the compiler inserts an exception in the GHC Core representation:

Fortunately, GHC will warn us by default about missing record fields.

Bottoms are used extensively throughout the Prelude, although this fact may not be immediately apparent. The reasons for including bottoms are either practical or historical.

The canonical example is the function which has type . This function could not be well-typed without the bottom.

It is rare to see these partial functions thrown around carelessly in production code because they cause the program to halt. The preferred method for handling exceptions is to combine the use of safe variants provided in with the usual fold functions and .

Another method is to use pattern matching, as shown in , a safer version of described below:

Invoking a bottom defined in terms of typically will not generate any position information. However, , which is used to provide assertions, can be short-circuited to generate position information in the place of either or calls.

Pattern matching in Haskell allows for the possibility of non-exhaustive patterns. For example, passing Nothing to will cause the program to crash at runtime. However, this function is an otherwise valid, type-checked program.

Since takes a value as its argument, two possible values are valid input: and . Since the case of a was not defined in , we say that the pattern matching within that function is non-exhaustive. In other words, the function does not implement appropriate handling of all valid inputs. Instead of yielding a value, such a function will halt from an incomplete match.

Partial functions from non-exhaustivity are a controversial subject, and frequent use of non-exhaustive patterns is considered a dangerous code smell. However, the complete removal of non-exhaustive patterns from the language would itself be too restrictive and forbid too many valid programs.

Several flags exist that we can pass to the compiler to warn us about such patterns or forbid them entirely either locally or globally.

The or flag can also be added on a per-module basis by using the pragma.

A more subtle case of non-exhaustivity is the use of implicit pattern matching with a single uni-pattern in a lambda expression. In a manner similar to the function above, a uni-pattern cannot handle all types of valid input. For instance, the function will fail when given a Nothing, even though the type of the lambda expression's argument is a .

Non-exhaustivity arising from uni-patterns in lambda expressions occurs frequently in or -blocks after desugaring, because such code is translated into lambda expressions similar to .

GHC can warn about these cases of non-exhaustivity with the flag.

Grossly speaking, any non-trivial program will use some measure of partial functions. It is simply a fact. Thus, there exist obligations for the programmer than cannot be manifest in the Haskell type system.

Since GHCi version 6.8.1, a built-in debugger has been available, although its use is somewhat rare. Debugging uncaught exceptions from bottoms or asynchronous exceptions is in similar style to debugging segfaults with gdb.

With runtime profiling enabled, GHC can also print a stack trace when a diverging bottom term (error, undefined) is hit. This action, though, requires a special flag and profiling to be enabled, both of which are disabled by default. So, for example:

And indeed, the runtime tells us that the exception occurred in the function and enumerates the call stack.

It is best to run this code without optimizations applied so as to preserve the original call stack as represented in the source. With optimizations applied, GHC will rearrange the program in rather drastic ways, resulting in what may be an entirely different call stack.

Since Haskell is a pure language, it has the unique property that most code is introspectable on its own. As such, using printf to display the state of the program at critical times throughout execution is often unnecessary because we can simply open GHCi and test the function. Nevertheless, Haskell does come with an unsafe function which can be used to perform arbitrary print statements outside of the IO monad.

In addition to the function, several monadic variants are quite common.

Since the release of GHC 7.8, typed holes allow for debugging incomplete programs. By placing an underscore on any value on the right hand-side of a declaration, GHC will throw an error during type-checking. Such an error reflects what type the value in the position of the type hole could be in order for the program to type-check successfully.

GHC has rightly suggested that the expression needed to finish the program is .

Since the release of version 7.8, GHC supports the option of treating type errors as runtime errors. With this option enabled, programs will run, but they will fail when a mistyped expression is evaluated. This feature is enabled with the flag in three ways: at the module level, when compiled from the command line, or inside of a GHCi interactive session.

For instance, the program below will compile:

However, when a pathological term is evaluated at runtime, we'll see a message like:

This error tells us that while has a declared type of , the body of the function has a type of . However, if the term is never evaluated, GHC will not throw an exception.

ghcid is a lightweight IDE hook that allows continuous feedback whenever code is updated. It can be run from the command line in the root of the project directory by specifying a command to run (e.g. , , or ).

When a Haskell module is loaded into , the code is evaluated in order to provide the user with any errors or warnings that would happen at compile time. When the developer edits and saves code loaded into , the program automatically reloads and evaluates the code for errors and warnings.

Haddock is the automatic documentation generation tool for Haskell source code. It integrates with the usual toolchain. In this section, we will explore how to document code so that Haddock can generate documentation successfully.

Several frequent comment patterns are used to document code for Haddock. The first of these methods uses to delineate the beginning of a comment:

Multiline comments are also possible:

is also used to comment Constructors or Record fields:

Elements within a module (i.e. value, types, classes) can be hyperlinked by enclosing the identifier in single quotes:

Modules themselves can be referenced by enclosing them in double quotes:

also allows the user to include blocks of code within the generated documentation. Two methods of demarcating the code blocks exist in . For example, enclosing a code snippet in symbols marks it as a code block:

Similarly, it's possible to use bird tracks ( ) in a comment line to set off a code block. This usage is very similar to Bird style Literate Haskell.

Snippets of interactive shell sessions can also be included in documentation. In order to denote the beginning of code intended to be run in a REPL, the symbol is used:

Headers for specific blocks can be added by prefacing the comment in the module block with a :

Sections can also be delineated by blocks that pertain to references in the body of the module:

Links can be added with the following syntax:

Images can also be included, so long as the path is either absolute or relative to the directory in which is run.

options can also be specified with pragmas in the source, either at the module or project level.

Much ink has been spilled waxing lyrical about the supposed mystique of monads. Instead, I suggest a path to enlightenment:

In other words, the only path to understanding monads is to read the fine source, fire up GHC, and write some code. Analogies and metaphors will not lead to understanding.

The following are all false:

See: What a Monad Is Not

Monads are not complicated. They are implemented as a typeclass with two methods, and (pronounced "bind"). In order to implement a Monad instance, these two functions must be defined in accordance with the arity described in the typeclass definition:

The first type signature in the Monad class definition is for . Any preconceptions one might have for the word "return" should be discarded: It has an entirely different meaning in the context of Haskell and acts very differently than in languages like C, Python, or Java. Instead of being the final arbiter of what value a function produces, in Haskell injects a value of type into a monadic context (e.g., Maybe, Either, etc.), which is denoted as .

The other function essential to implementing a Monad instance is . This infix takes two arguments. On its left side is a value with type , while on the right side is a function with type . The bind operation results in a final value of type .

A third, auxiliary function ( ) is defined in terms of the bind operation that discards its argument.

This definition says that (>>) has a left and right argument which are monadic with types and respectively, while the infix returns a value of type . The actual implementation of (>>) says that when is passed to with on the right, the value will always be returned.

In addition to specific implementations of and , all monad instances must satisfy three laws.

The first law says that when is passed through a into a function , this expression is exactly equivalent to .

In discussing the next two laws, we'll refer to a value . This notation is shorthand for value wrapped in a monadic context. Such a value has type , and could be represented more concretely by values like , , or . It is important to note that some of these concrete instantiations of the value have multiple components. In discussing the second and third monad laws, we'll see some examples of how this plays out.

The second law states that a monadic value passed through into is exactly equivalent to itself. In other words, using bind to pass a monadic value to does not change the initial value.

A more explicit way to write the second Monad law exists. In this following example code, the first expression shows how the second law applies to values represented by non-nullary type constructors. The second snippet shows how a value represented by a nullary type constructor works within the context of the second law.

While the first two laws are relatively clear, the third law may be more difficult to understand. This law states that when a monadic value is passed through to the function and then the result of that expression is passed to , the entire expression is exactly equivalent to passing to a lambda expression that takes one parameter and outputs the function applied to . By the definition of bind, must return a value wrapped in the same Monad. Because of this property, the resultant value of that expression can be passed through to the function , which also returns a monadic value.

Again, it is possible to write this law with more explicit code. Like in the explicit examples for law 2, has been replaced by in order to be very clear that there can be multiple components to a monadic value. Although little has changed in the code, it is easier to see what value--namely, --corresponds to the in the lambda expression. After is passed through to , the function operates on and returns a result still wrapped in the type constructor. We can call this new value . Since it is still wrapped in the monadic context, can thus be passed through the bind operation into the function .

Monadic syntax in Haskell is written in a sugared form, known as notation. The advantages of this special syntax are that it is easier to write and is entirely equivalent to just applications of the monad operations. The desugaring is defined recursively by the rules:

Thus, through the application of the desugaring rules, the following expressions are equivalent:

If one were to write the bind operator as an uncurried function ( this is not how Haskell uses it ) the same desugaring might look something like the following chain of nested binds with lambdas.

In the do-notation, the monad laws from above are equivalently written:

The Maybe monad is the simplest first example of a monad instance. The Maybe monad models computations which fail to yield a value at any point during computation.

The Maybe type has two value constructors. The first, , is a unary constructor representing a successful computation, while the second, , is a nullary constructor that represents failure.

The monad instance describes the implementation of for by pattern matching on the possible inputs that could be passed to the bind operation (i.e., or ). The instance declaration also provides an implementation of , which in this case is simply .

The following code shows some simple operations to do within the Maybe monad.

In the first example, The value is passed via to the lambda function . refers to the portion of , and we can use in the second half of the lambda expression, where evaluates to , indicating a successful computation.

In the second example, the value is passed via to the same lambda function as in the previous example. However, according to the Monad instance, whenever is bound to a function, the expression's result will be .

In the next example, is applied to and returns .

The next code examples show the use of notation within the Maybe monad to do addition that might fail. Desugared examples are provided as well.

The List monad is the second simplest example of a monad instance. As always, this monad implements both and . The definition of bind says that when the list is bound to a function , the result is a concatenation of over the list . The method simply takes a single value and injects into a singleton list .

In order to demonstrate the monad's methods, we will define two functions: and . is a simple list, while is a function that takes a single and returns a two element list .

The evaluation proceeds as follows:

The list comprehension syntax in Haskell can be implemented in terms of the list monad. List comprehensions can be considered syntactic sugar for more obviously monadic implementations. Examples and illustrate these use cases.

The first example ( ) illustrates how to write a list comprehension. Although the syntax looks strange at first, there are elements of it that may look familiar. For instance, the use of is just like bind in a notation: It binds an element of a list to a name. However, one major difference is apparent: seems to lack a call to . Not to worry, though, the fills this role. This syntax can be easily desugared by the compiler to an explicit invocation of . Furthermore, it serves to remind the user that the computation takes place in the List monad.

The second example ( ) shows the list comprehension above rewritten with notation:

The final examples are further illustrations of the List monad. The functions below each return a list of 3-tuples which contain the possible combinations of the three lists that get bound the names , , and . N.B.: Only values in the list bound to can be used in position of the tuple; the same fact holds true for the lists bound to and .

Perhaps the most (in)famous example in Haskell of a type that forms a monad is . A value of type is a computation which, when performed, does some I/O before returning a value of type . These computations are called actions. IO actions executed in are the means by which a program can operate on or access information in the external world. IO actions allow the program to do many things, including, but not limited to:

Conceptualizing I/O as a monad enables the developer to access information outside the program, but operate on the data with pure functions. The following examples will show how we can use IO actions and IO values to receive input from stdin and print to stdout.

Perhaps the most immediately useful function for doing I/O in Haskell is . This function takes a and returns an . Calling it from will result in the being printed to stdout followed by a newline character.

Here is some code that prints a couple of lines to the terminal. The first invocation of is executed, causing the to be printed to stdout. The result is bound to a lambda expression that discards its argument, and then the next is executed.

Another useful function is which has type . This function gets a line of input from stdin. The developer can then bind this line to a name in order to operate on the value within the program.

The code below demonstrates a simple combination of these two functions as well as desugaring code. First, prints a to stdout to ask the user to supply their name, with the result being bound to a lambda that discards it argument. Then, is executed, supplying a prompt to the user for entering their name. Next, the resultant is bound to and passed to . Finally, the program prints the name to the terminal.

The next code block is the desugared equivalent of the previous example; however, the uses of are made explict.

Our final example executes in the same way as the previous two examples. This example, though, uses the special operator to take the place of binding a result to the lamda that discards its argument.

Although it is difficult, if not impossible, to touch, see, or otherwise physically interact with a monad, this construct has some very interesting implications for programmers. For instance, consider the non-intuitive fact that we now have a uniform interface for talking about three very different, but foundational ideas for programming: Failure, Collections and Effects.

Let's write down a new function called which folds a function over a list of monadic computations. We can think of as analogous to the list constructor (i.e. ) except it pulls the two list elements out of two monadic values ( , ) by means of bind. The bound values are then joined with the list constructor , before finally being rewrapped in the appropriate monadic context with .

What does this function mean in terms of each of the monads discussed above?

Sequencing a list of values within the context allows us to collect the results of a series of computations which can possibly fail. However, yields the aggregated values only if each computation succeeds. In other words, if even one of the values in the initial list passed to is a , the result of will also be .

The bind operation for the list monad forms the pairwise list of elements from the two operands. Thus, folding the binds contained in over a list of lists with implements the general Cartesian product for an arbitrary number of lists.

Applying within the IO context results in still a different result. The function takes a list of IO actions, performs them sequentially, and then returns the list of resulting values in the order sequenced.

So there we have it, three fundamental concepts of computation that are normally defined independently of each other actually all share this similar structure. This unifying pattern can be abstracted out and reused to build higher abstractions that work for all current and future implementations. If you want a motivating reason for understanding monads, this is it! These insights are the essence of what I wish I knew about monads looking back.

The reader monad lets us access shared immutable state within a monadic context.

The writer monad lets us emit a lazy stream of values from within a monadic context.

This implementation is lazy, so some care must be taken that one actually wants to only generate a stream of thunks. Most often the lazy writer is not suitable for use, instead implement the equivalent structure by embedding some monomial object inside a StateT monad, or using the strict version.

The state monad allows functions within a stateful monadic context to access and modify shared state.

The state monad is often mistakenly described as being impure, but it is in fact entirely pure and the same effect could be achieved by explicitly passing state. A simple implementation of the State monad takes only a few lines:

So many monad tutorials have been written that it begs the question: what makes monads so difficult when first learning Haskell? I hypothesize there are three aspects to why this is so:

A lot of the Haskell we write is radically rearranged and transformed into an entirely new form under the hood.

Most monad tutorials will not manually expand out the do-sugar. This leaves the beginner thinking that monads are a way of dropping into a pseudo-imperative language inside of code and further fuels that misconception that specific instances like IO are monads in their full generality.

Being able to manually desugar is crucial to understanding.

On the left hand side of the operator we have an and on the right we have . Although some languages do have infix operators that are themselves higher order functions, it is still a rather rare occurrence.

So with a function desugared, it can be confusing that operator is in fact building up a much larger function by composing functions together.

Written in prefix form, it becomes a little bit more digestible.

Perhaps even removing the operator entirely might be more intuitive coming from other languages.

Haskell's implementation of overloading can be unintuitive if one is not familiar with type inference. It is abstracted away from the user, but the or function is really a function of 3 arguments with the extra typeclass dictionary argument ( ) implicitly threaded around.

Except in the case where the parameter of the monad class is unified ( through inference ) with a concrete class instance, in which case the instance dictionary ( ) is instead spliced throughout.

Now, all of these transformations are trivial once we understand them, they're just typically not discussed. In my opinion the fundamental fallacy of monad tutorials is not that intuition for monads is hard to convey ( nor are metaphors required! ), but that novices often come to monads with an incomplete understanding of points (1), (2), and (3) and then trip on the simple fact that monads are the first example of a Haskell construct that is the confluence of all three.

So, the descriptions of Monads in the previous chapter are a bit of a white lie. Modern Haskell monad libraries typically use a more general form of these, written in terms of monad transformers which allow us to compose monads together to form composite monads. The monads mentioned previously are subsumed by the special case of the transformer form composed with the Identity monad.

In terms of generality the mtl library is the most common general interface for these monads, which itself depends on the transformers library which generalizes the "basic" monads described above into transformers.

At their core monad transformers allow us to nest monadic computations in a stack with an interface to exchange values between the levels, called .

Just as the base monad class has laws, monad transformers also have several laws:

It's useful to remember that transformers compose outside-in but are unrolled inside out.

The most basic use requires us to use the T-variants for each of the monad transformers in the outer layers and to explicitly and values between the layers. Monads have kind , so monad transformers which take monads to monads have :

So, for example, if we wanted to form a composite computation using both the Reader and Maybe monads we can now put the Maybe inside of a to form .

The fundamental limitation of this approach is that we find ourselves ing and ing a lot.

For example, there exist three possible forms of the Reader monad. The first is the Haskell 98 version that no longer exists, but is useful for understanding the underlying ideas. The other two are the transformers and mtl variants.

So, hypothetically the three variants of ask would be:

In practice only the last one is used in modern Haskell.

Newtypes let us reference a data type with a single constructor as a new distinct type, with no runtime overhead from boxing, unlike an algebraic datatype with a single constructor. Newtype wrappers around strings and numeric types can often drastically reduce accidental errors.

Consider the case of using a newtype to distinguish between two different text blobs with different semantics. Both have the same runtime representation as a text object, but are distinguished statically, so that plaintext can not be accidentally interchanged with encrypted text.

The other common use case is using newtypes to derive logic for deriving custom monad transformers in our business logic. Using we can recover the functionality of instances of the underlying types composed in our transformer stack.

Using newtype deriving with the mtl library typeclasses we can produce flattened transformer types that don't require explicit lifting in the transform stack. For example, here is a little stack machine involving the Reader, Writer and State monads.

Pattern matching on a newtype constructor compiles into nothing. For example the function does not scrutinize the constructor like the does, because does not exist at runtime, it is purely a compile-time construct.

The second monad transformer law guarantees that sequencing consecutive lift operations is semantically equivalent to lifting the results into the outer monad.

Although they are guaranteed to yield the same result, the operation of lifting the results between the monad levels is not without cost and crops up frequently when working with the monad traversal and looping functions. For example, all three of the functions on the left below are less efficient than the right hand side which performs the bind in the base monad instead of lifting on each iteration.

The base monad transformer package provides a class for lifting to another monad:

But often times we need to work with and manipulate our monad transformer stack to either produce new transformers, modify existing ones or extend an upstream library with new layers. The library provides the capacity to compose monad morphism transformation directly on transformer stacks. The equivalent of type transformer type-level map is the function.

Hoist takes a monad morphism (a mapping from a to a ) and applies in on the inner value monad of a transformer stack, transforming the value under the outer layer.

The monad morphism takes an Identity monad into any another monad .

For example, it generalizes (which is ) to .

So we can generalize an existing transformer to lift an IO layer onto it.

It's important to distinguish between different categories of language extensions general and specialized.

The inherent problem with classifying the extensions into the general and specialized categories is that it's a subjective classification. Haskellers who do type system research will have a very different interpretation of Haskell than people who do web programming. As such this is a conservative assessment, as an arbitrary baseline let's consider and "everyday" while and are "specialized".

It's not obvious which extensions are the most common but it's fairly safe to say that these extensions are benign and are safely used extensively:

GHC's typechecker sometimes just casually tells us to enable language extensions when it can't solve certain problems. These include:

These almost always indicate a design flaw and shouldn't be turned on to remedy the error at hand, as much as GHC might suggest otherwise!

Inference in Haskell is usually precise, although there are several boundary cases where inference is difficult or impossible to infer a principal type of an expression. There a two common cases:

The inferred type signatures are correct in their usage, but don't represent the most general signatures. When GHC analyzes the module it analyzes the dependencies of expressions on each other, groups them together, and applies substitutions from unification across mutually defined groups. As such the inferred types may not be the most general types possible, and an explicit signature may be desired.

The problem with this expression is because the inferred type variable in spans two possible types ( and ), the recursion is polymorphic. These two types won't pass the occurs-check of the typechecker and it yields an incorrect inferred type.

Simply adding an explicit type signature corrects this. Type inference using polymorphic recursion is undecidable in the general case.

See: Static Semantics of Function and Pattern Bindings

The most common edge case of the inference is known as the dreaded monomorphism restriction.

When the toplevel declarations of a module are generalized the monomorphism restricts that toplevel values (i.e. expressions not under a lambda ) whose type contains the subclass of the type from the Prelude are not generalized and instead are instantiated with a monotype tried sequentially from the list specified by the which is normally , then .

As of GHC 7.8, the monomorphism restriction is switched off by default in GHCi.

Haskell normally applies several defaulting rules for ambigious literals in the absence of an explicit type signature. When an ambiguous literal is typechecked if at least one of its typeclass constraints is numeric and all of its classes are standard library classes, the module's default list is consulted, and the first type from the list that will satisfy the context of the type variable is instantiated. So for instance given the following default rules.

The following set of heuristics is used to determine what to instnatiate the ambiguous type variable to.

This is normally fine, but sometimes we'd like more granular control over defaulting. The loosens the restriction that we're constrained with working on Numerical typeclasses and the constraint that we can only work with standard library classes. If we'd like to have our string literals (using -XOverlodaedStrings) automatically default to the more efficient implementation instead of we can twiddle the flag and GHC will perform the right substitution without the need for an explicit annotation on every string literal.

For code typed at the GHCi prompt, the flag is always on, and cannot be switched off.

As everyone eventually finds out there are several functions within the implementation of GHC ( not the Haskell language ) that can be used to subvert the type-system, they are marked with the prefix . These functions exist only for when one can manually prove the soundness of an expression but can't express this property in the type-system or externalities to Haskell.

The Safe Haskell language extensions allow us to restrict the use of unsafe language features using which restricts the import of modules which are themselves marked as Safe. It also forbids the use of certain language extensions ( ) which can be used to produce unsafe code. The primary use case of these extensions is security auditing.

The same hole technique can be applied at the toplevel for signatures:

Pattern wildcards can also be given explicit names so that GHC will use when reporting the inferred type in the resulting message.

The same wildcards can be used in type contexts to dump out inferred type class constraints:

When the flag is passed to GHC and the inferred type is unambiguous, GHC will let us leave the holes in place and the compilation will proceed.

Recursive do notation allows to use to self-reference expressions on both sides of a monadic bind. For instance the following uses lazy evaluation to generate a infinite list. This is sometimes used for instantiating cyclic datatypes inside of a monadic context that need to hold a reference to themselves.

By default GHC desugars do-notation to use implicit invocations of bind and return.

With this instead desugars into use of applicative combinators and a laxer Applicative constraint.

Pattern guards are an extension to the pattern matching syntax. Given a pattern qualifier, the right hand side is evaluated and matched against the pattern on the left. If the match fails then the whole guard fails and the next equation is tried. If it succeeds, then the appropriate binding takes place, and the next qualifier is matched, in the augmented environment.

View patterns are like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of algebraic data types.

GHC normally requires at least one pattern branch in case statement this restriction can be relaxed with -XEmptyCase. The case statement then immediately yields a if evaluated.

For case statements, LambdaCase allows the elimination of redundant free variables introduced purely for the case of pattern matching on.

NumDecimals allows the use of exponential notation for integral literals that are not necessarily floats. Without it, any use of expontial notation induces a Fractional class constraint.

Package imports allows us to disambiguate hierarchical package names by their respective package key. This is useful in the case where you have to imported packages that expose the same module. In practice most of the common libraries have taken care to avoid conflicts in the namespace and this is not usually a problem in most modern Haskell.

For example we could explicitly ask GHC to resolve that package be drawn from the library.

Record wild cards allow us to expand out the names of a record as variables scoped as the labels of the record implicitly. The extension can be used to extract variables names into a scope or to assign to variables in a record drawing, aligning the record's labels with the variables in scope for the assignment. The syntax introduced is the pattern selector.

Provides alternative syntax for accessing record fields in a pattern match.

Suppose we were writing a typechecker, it would be very common to include a distinct term to ease the telescoping of function signatures, this is what GHC does in its Core language. Even though technically it could be written in terms of more basic application of the constructor.

With pattern synonyms we can eliminate the extraneous constructor without losing the convenience of pattern matching on arrow types.

So now we can write an eliminator and constructor for arrow type very naturally.

Pattern synonyms can be exported from a module like any other definition by prefixing them with the prefix .

With we can derive any class. The deriving logic s generates an instance declaration for the type with no explicitly-defined methods. If the typeclass implements a default for each method then this will be well-defined and give rise to an automatic instances.

GHC 8.0 introduced the DuplicateRecordFields extensions which loosens GHC's restriction on records in the same module with identical accessors. The precise type that is being projected into is now deferred to the callsite.

Using just DuplicateRecordFields, projection is still not supported so the following will not work. OverloadedLabels fixes this to some extent.

GHC 8.0 also introduced the OverloadedLabels extension which allows a limited form of polymorphism over labels that share the same name.

To work with overloaded labels types we need to enable several language extensions to work with promoted strings and multiparam typeclasses that underly it's implementation.

The C++ preprocessor is the fallback whenever we really need to separate out logic that has to span multiple versions of GHC and language changes while maintaining backwards compatibility. It can dispatch on the version of GHC being used to compile a module.

To demarcate code based on the operating system compiled on.

Or on the version of the base library used.

It can also be abused to do terrible things like metaprogrammming with strings, but please don't do this.

Several language extensions have either been absorbed into the core language or become deprecated in favor of others. Others are just considered misfeatures.

In the presence of default implementations of typeclasses methods, there may be several ways to implement a typeclass. For instance Eq is entirely defined by either defining when two values are equal or not equal by implying taking the negation of the other. We can define equality in terms of non-equality and vice-versa.

Before 7.6.1 there was no way to specify what was the "minimal" definition required to implement a typeclass

Minimal pragmas are boolean expressions, with as logical , either definition must be defined). Comma indicates logical where both sides both definitions must be defined.

Compiling the will warn when a instance is defined that does not meet the minimal criterion.

Typeclasses are normally globally coherent, there is only ever one instance that can be resolved for a type unambiguously for a type at any call site in the program. There are however extensions to loosen this restriction and perform more manual direction of the instance search.

Overlapping instances loosens the coherent condition (there can be multiple instances) but introduces a criterion that it will resolve to the most specific one.

Historically enabling this on module-level was not the best idea, since generally we define multiple classes in a module only a subset of which may be incoherent. So as of 7.10 we now have the capacity to just annotate instances with the OVERLAPPING and INCOHERENT pragmas.

Incoherent instance loosens the restriction that there be only one specific instance, will choose one arbitrarily (based on the arbitrary sorting of it's internal representation ) and the resulting program will typecheck. This is generally pretty crazy and usually a sign of poor design.

There is also an incoherent instance.

Again, a subject on which much ink has been spilled. There is an ongoing discussion in the land of Haskell about the compromises between lazy and strict evaluation, and there are nuanced arguments for having either paradigm be the default. Haskell takes a hybrid approach and allows strict evaluation when needed and uses laziness by default. Needless to say, we can always find examples where strict evaluation exhibits worse behavior than lazy evaluation and vice versa.

The primary advantage of lazy evaluation in the large is that algorithms that operate over both unbounded and bounded data structures can inhabit the same type signatures and be composed without additional need to restructure their logic or force intermediate computations. Languages that attempt to bolt laziness on to a strict evaluation model often bifurcate classes of algorithms into ones that are hand-adjusted to consume unbounded structures and those which operate over bounded structures. In strict languages mixing and matching between lazy vs strict processing often necessitates manifesting large intermediate structures in memory when such composition would "just work" in a lazy language.

By virtue of Haskell being the only language to actually explore this point in the design space to the point of being industrial strength; knowledge about lazy evaluation is not widely absorbed into the collective programmer consciousness and can often be non-intuitive to the novice. This doesn't reflect on the model itself, merely on the need for more instruction material and research on optimizing lazy compilers.

The paradox of Haskell is that it explores so many definably unique ideas ( laziness, purity, typeclasses ) that it becomes difficult to separate out the discussion of any one from the gestalt of the whole implementation.

There are several evaluation models for the lambda calculus:

These ideas give rise to several models, Haskell itself use the call-by-need model.

A term is said to be in weak head normal-form if the outermost constructor or lambda cannot be reduced further. A term is said to be in normal form if it is fully evaluated and all sub-expressions and thunks contained within are evaluated.

In Haskell normal evaluation only occurs at the outer constructor of case-statements in Core. If we pattern match on a list we don't implicitly force all values in the list. An element in a data structure is only evaluated up to the most outer constructor. For example, to evaluate the length of a list we need only scrutinize the outer Cons constructors without regard for their inner values.

For example, in a lazy language the following program terminates even though it contains diverging terms.

In a strict language like OCaml ( ignoring its suspensions for the moment ), the same program diverges.

In Haskell a thunk is created to stand for an unevaluated computation. Evaluation of a thunk is called forcing the thunk. The result is an update, a referentially transparent effect, which replaces the memory representation of the thunk with the computed value. The fundamental idea is that a thunk is only updated once ( although it may be forced simultaneously in a multi-threaded environment ) and its resulting value is shared when referenced subsequently.

The command can be used to introspect the state of unevaluated thunks inside an expression without forcing evaluation. For instance:

While a thunk is being computed its memory representation is replaced with a special form known as blackhole which indicates that computation is ongoing and allows for a short circuit for when a computation might depend on itself to complete. The implementation of this is some of the more subtle details of the GHC runtime.

The function introduces an artificial dependence on the evaluation of order of two terms by requiring that the first argument be evaluated to WHNF before the evaluation of the second. The implementation of the function is an implementation detail of GHC.

The infamous is well-known to leak space when used carelessly and without several compiler optimizations applied. The strict variant uses seq to overcome this.

In practice, a combination between the strictness analyzer and the inliner on will ensure that the strict variant of is used whenever the function is inlinable at call site so manually using is most often not required.

Of important note is that GHCi runs without any optimizations applied so the same program that performs poorly in GHCi may not have the same performance characteristics when compiled with GHC.

The extension allows an alternative syntax to force arguments to functions to be wrapped in seq. A bang operator on an arguments forces its evaluation to weak head normal form before performing the pattern match. This can be used to keep specific arguments evaluated throughout recursion instead of creating a giant chain of thunks.

This is desugared into code effectively equivalent to the following:

Function application to seq'd arguments is common enough that it has a special operator.

As of GHC 8.0 strictness annotations can be applied to all definitions in a module automatically. In previous versions it was necessary to definitions via explicit syntactic annotations at all sites.

Enabling StrictData makes constructor fields strict by default on any module it is enabled on.

Strict implies and extends strictness annotations to all arguments of functions.

Is equivalent to the following function declaration with explicit bang patterns:

On a module-level this effectively makes Haskell a call-by-value language with some caveats. All arguments to functions are now explicitly evaluated and all data in constructors within this module are in head normal form by construction. However there are some subtle points to this that are better explained in the language guide.

There are often times when for performance reasons we need to deeply evaluate a data structure to normal form leaving no terms unevaluated. The library performs this task.

The typeclass (Normal Form Data) allows us to seq all elements of a structure across any subtypes which themselves implement NFData.

To force a data structure itself to be fully evaluated we share the same argument in both positions of deepseq.

A lazy pattern doesn't require a match on the outer constructor, instead it lazily calls the accessors of the values as needed. In the presence of a bottom, we fail at the usage site instead of the outer pattern match.

Haskell being a 25 year old language has witnessed several revolutions in the way we structure and compose functional programs. Yet as a result several portions of the Prelude still reflect old schools of thought that simply can't be removed without breaking significant parts of the ecosystem.

Currently it really only exists in folklore which parts to use and which not to use, although this is a topic that almost all introductory books don't mention and instead make extensive use of the Prelude for simplicity's sake.

The short version of the advice on the Prelude is:

The instances of Foldable for the list type often conflict with the monomorphic versions in the Prelude which are left in for historical reasons. So often times it is desirable to explicitly mask these functions from implicit import and force the use of Foldable and Traversable instead.

Of course often times one wishes only to use the Prelude explicitly and one can explicitly import it qualified and use the pieces as desired without the implicit import of the whole namespace.

To get work done you probably need.

The default Prelude can be disabled in it's entirety by twiddling the flag.

We are then free to build an equivalent Prelude that is more to our liking. Using module reexporting we can pluck the good parts of the prelude and libraries like to build up a more industrial focused set of default functions. For example:

The Prelude itself is entirely replicable as well, presuming that an entire project is compiled without the implicit Prelude. Several packages have arisen that supply much of the same functionality in a way that appeals to more modern design principles.

Protolude is a minimalist Prelude which provides many sensible defaults for writing modern Haskell and is compatible with existing code.

Other examples for alternative Preludes include (your mileage may vary with these):

A partial function is a function which doesn't terminate and yield a value for all given inputs. Conversely a total function terminates and is always defined for all inputs. As mentioned previously, certain historical parts of the Prelude are full of partial functions.

The difference between partial and total functions is the compiler can't reason about the runtime safety of partial functions purely from the information specified in the language and as such the proof of safety is left to the user to guarantee. They are safe to use in the case where the user can guarantee that invalid inputs cannot occur, but like any unchecked property its safety or not-safety is going to depend on the diligence of the programmer. This very much goes against the overall philosophy of Haskell and as such they are discouraged when not necessary.

The Prelude has total variants of the historical partial functions (i.e. )in some cases, but often these are found in the various utility libraries like .

The total versions provided fall into three cases:

The problem with the boolean type is that there is effectively no difference between True and False at the type level. A proposition taking a value to a Bool takes any information given and destroys it. To reason about the behavior we have to trace the provenance of the proposition we're getting the boolean answer from, and this introduces a whole slew of possibilities for misinterpretation. In the worst case, the only way to reason about safe and unsafe use of a function is by trusting that a predicate's lexical name reflects its provenance!

For instance, testing some proposition over a Bool value representing whether the branch can perform the computation safely in the presence of a null is subject to accidental interchange. Consider that in a language like C or Python testing whether a value is null is indistinguishable to the language from testing whether the value is not null. Which of these programs encodes safe usage and which segfaults?

From inspection we can't tell without knowing how p is defined, the compiler can't distinguish the two either and thus the language won't save us if we happen to mix them up. Instead of making invalid states unrepresentable we've made the invalid state indistinguishable from the valid one!

The more desirable practice is to match on terms which explicitly witness the proposition as a type ( often in a sum type ) and won't typecheck otherwise.

To be fair though, many popular languages completely lack the notion of sum types ( the source of many woes in my opinion ) and only have product types, so this type of reasoning sometimes has no direct equivalence for those not familiar with ML family languages.

In Haskell, the Prelude provides functions like and both of which can be used to subvert this kind of reasoning and make it easy to introduce bugs and should often be avoided.

If coming from an imperative background retraining one's self to think about iteration over lists in terms of maps, folds, and scans can be challenging.

For a concrete consider the simple arithmetic sequence over the binary operator :

Foldable and Traversable are the general interface for all traversals and folds of any data structure which is parameterized over its element type ( List, Map, Set, Maybe, ...). These two classes are used everywhere in modern Haskell and are extremely important.

A foldable instance allows us to apply functions to data types of monoidal values that collapse the structure using some logic over .

A traversable instance allows us to apply functions to data types that walk the structure left-to-right within an applicative context.

The function is extremely general and non-intuitively many of the monomorphic list folds can themselves be written in terms of this single polymorphic function.

takes a function of values to a monoidal quantity, a functor over the values and collapses the functor into the monoid. For instance for the trivial Sum monoid:

For instance if we wanted to map a list of some abstract element types into a hashtable of elements based on pattern matching we could use it.

The full Foldable class (with all default implementations) contains a variety of derived functions which themselves can be written in terms of and .

Most of the operations over lists can be generalized in terms of combinations of Foldable and Traversable to derive more general functions that work over all data structures implementing Foldable.

Unfortunately for historical reasons the names exported by foldable quite often conflict with ones defined in the Prelude, either import them qualified or just disable the Prelude. The operations in the Foldable all specialize to the same and behave the same as the ones in Prelude for List types.

The instances we defined above can also be automatically derived by GHC using several language extensions. The automatic instances are identical to the hand-written versions above.

A recursive function consumes data and eventually terminates, a corecursive function generates data and coterminates. A corecursive function is said to be productive if it can always evaluate more of the resulting value in bounded time.

The split package provides a variety of missing functions for splitting list and string types.

The monad-loops package provides a variety of missing functions for control logic in monadic contexts.

The default Haskell string type is implemented as a naive linked list of characters, this is terrible for most purposes but no one knows how to fix it without rewriting large portions of all code that exists and nobody can commit the time to fix it. So it remains broken, likely forever.

For more performance sensitive cases there are two libraries for processing textual data: and .

For each of these there are two variants for both text and bytestring.

Giving rise to the four types.

Conversions between strings types ( from : left column, to : top row ) are done with several functions across the bytestring and text libraries. The mapping between text and bytestring is inherently lossy so there is some degree of freedom in choosing the encoding. We'll just consider utf-8 for simplicity.

With the extension string literals can be overloaded without the need for explicit packing and can be written as string literals in the Haskell source and overloaded via a typeclass . Sometimes this is desirable.

We can also derive IsString for newtypes using , although much of the safety of the newtype is then lost if it is interchangeable with other strings.

The Text.Builder allows the efficient monoidal construction of lazy Text types without having to go through inefficient forms like String or List types as intermediates.

ByteStrings are arrays of unboxed characters with either strict or lazy evaluation.

Haskell also has a variadic function in the style of C.

It is ubiquitous for data structure libraries to expose and functions to construct various structures out of lists. As of GHC 7.8 we now have the ability to overload the list syntax in the surface language with a typeclass .

Playing "type-tetris" to convert between Strings explicitly can be frustrating, fortunately there are several packages that automate the conversion using typeclasses to automatically convert between any two common string representations automatically. We can then write generic comparison and concatenation operators that automatically convert types of operands to a like form.

Like monads Applicatives are an abstract structure for a wide class of computations that sit between functors and monads in terms of generality.

As of GHC 7.6, Applicative is defined as:

With the following laws:

As an example, consider the instance for Maybe:

As a rule of thumb, whenever we would use what we probably want is an applicative functor, and not a monad.

The pattern shows up so frequently that there are a family of functions to lift applicatives of a fixed number arguments. This pattern also shows up frequently with monads ( , , ).

Applicative also has functions and that sequence applicative actions while discarding the value of one of the arguments. The operator discard the left while discards the right. For example in a monadic parser combinator library the would parse with first parser argument but return the second.

The Applicative functions and are generalized by and for monads.

Alternative is an extension of the Applicative class with a zero element and an associative binary operation respecting the zero.

These instances show up very frequently in parsers where the alternative operator can model alternative parse branches.

A category is an algebraic structure that includes a notion of an identity and a composition operation that is associative and preserves identities.

Arrows are an extension of categories with the notion of products.

The canonical example is for functions.

In this form functions of multiple arguments can be threaded around using the arrow combinators in a much more pointfree form. For instance a histogram function has a nice one-liner.

GHC has builtin syntax for composing arrows using notation. The following are equivalent after desugaring:

In practice this notation is not often used and may become deprecated in the future.

Bifunctors are a generalization of functors to include types parameterized by two parameters and include two map functions for each parameter.

The bifunctor laws are a natural generalization of the usual functor. Namely they respect identities and composition in the usual way:

The canonical example is for 2-tuples.

One surprising application of typeclasses is the ability to construct functions which take an arbitrary number of arguments by defining instances over function types. The arguments may be of arbitrary type, but the resulting collected arguments must either converted into a single type or unpacked into a sum type.

The low-level (and most dangerous) way to handle errors is to use the and functions which allow us to throw extensible exceptions in pure code but catch the resulting exception within IO. Of specific note is that return value of the inhabits all types. There's no reason to use this for custom code that doesn't use low-level system operations.

Because a value will not be evaluated unless needed, if one desires to know for sure that an exception is either caught or not it can be deeply forced into head normal form before invoking catch. The is not provided by standard library but has a simple implementation in terms of .

The problem with the previous approach is having to rely on GHC's asynchronous exception handling inside of IO to handle basic operations. The provides the same API as but loosens the dependency on IO.

As of mtl 2.2 or higher, the class has been replaced by the . At transformers level.

Sometimes you'll be forced to deal with seemingly pure functions that can throw up at any point. There are many functions in the standard library like this, and many more on Hackage. You'd like to be handle this logic purely as if it were returning a proper but to catch the logic you'd need to install a IO handler inside IO to catch it. Spoon allows us to safely (and "purely", although it uses a referentially transparent invocation of unsafePerformIO) to catch these exceptions and put them in Maybe where they belong.

The function evaluates its argument to head normal form, while evaluates to weak head normal form.

If one writes Haskell long enough one might eventually encounter the curious beast that is the monad instance. It generally tends to be non-intuitive to work with, but is quite simple when one considers it as an unwrapped Reader monad.

This just uses a prefix form of the arrow type operator.

The RWS monad combines the functionality of the three monads discussed above, the Reader, Writer, and State. There is also a transformer.

These three eval functions are now combined into the following functions:

The usual caveat about Writer laziness also applies to RWS.

In continuation passing style, composite computations are built up from sequences of nested computations which are terminated by a final continuation which yields the result of the full computation by passing a function into the continuation chain.

The fixed point of a monadic computation. executes the action only once, with the eventual output fed back as the input.

The regular do-notation can also be extended with to accommodate recursive monadic bindings.

The ST monad models "threads" of stateful computations which can manipulate mutable references but are restricted to only return pure values when evaluated and are statically confined to the ST monad of a thread.

Using the ST monad we can create a class of efficient purely functional data structures that use mutable references in a referentially transparent way.

Free monads are monads which instead of having a operation that combines computations, instead forms composite computations from application of a functor.

One of the best examples is the Partiality monad which models computations which can diverge. Haskell allows unbounded recursion, but for example we can create a free monad from the functor which can be used to fix the call-depth of, for example the Ackermann function.

The other common use for free monads is to build embedded domain-specific languages to describe computations. We can model a subset of the IO monad by building up a pure description of the computation inside of the IOFree monad and then using the free monad to encode the translation to an effectful IO computation.

An implementation such as the one found in free might look like the following:

Indexed monads are a generalisation of monads that adds an additional type parameter to the class that carries information about the computation or structure of the monadic implementation.

The canonical use-case is a variant of the vanilla State which allows type-changing on the state for intermediate steps inside of the monad. This indeed turns out to be very useful for handling a class of problems involving resource management since the extra index parameter gives us space to statically enforce the sequence of monadic actions by allowing and restricting certain state transitions on the index parameter at compile-time.

To make this more usable we'll use the somewhat esoteric allowing us to overload the do-notation and if-then-else syntax by providing alternative definitions local to the module.

The default prelude predates a lot of the work on monad transformers and as such many of the common functions for handling errors and interacting with IO are bound strictly to the IO monad and not to functions implementing stacks on top of IO or ST. The lifted-base provides generic control operations such as can be lifted from IO or any other base monad.

Monad base provides an abstraction over and other functions to explicitly lift into a "privileged" layer of the transformer stack. It's implemented a multiparamater typeclass with the "base" monad as the parameter b.

Monad control builds on top of monad-base to extended lifting operation to control operations like and can be written generically in terms of any transformer with a base layer supporting these operations. Generic operations can then be expressed in terms of a and written in terms of the combinator which handles the bracket and automatic handler lifting.

For example the function catch provided by is normally locked into IO.

By composing it in terms of control we can construct a generic version which automatically lifts inside of any combination of the usual transformer stacks that has instance.

Universal quantification the primary mechanism of encoding polymorphism in Haskell. The essence of universal quantification is that we can express functions which operate the same way for a set of types and whose function behavior is entirely determined only by the behavior of all types in this span.

Normally quantifiers are omitted in type signatures since in Haskell's vanilla surface language it is unambiguous to assume to that free type variables are universally quantified.

A universally quantified type-variable actually implies quite a few rather deep properties about the implementation of a function that can be deduced from its type signature. For instance the identity function in Haskell is guaranteed to only have one implementation since the only information that the information that can present in the body

The Hindley-Milner type system is historically important as one of the first typed lambda calculi that admitted both polymorphism and a variety of inference techniques that could always decide principal types.

In an implementation, the function converts all type variables within the type into polymorphic type variables yielding a type scheme. The function maps a scheme to a type, but with any polymorphic variables converted into unbound type variables.

System-F is the type system that underlies Haskell. System-F subsumes the HM type system in the sense that every type expressible in HM can be expressed within System-F. System-F is sometimes referred to in texts as the Girald-Reynolds polymorphic lambda calculus or second-order lambda calculus.

An example with equivalents of GHC Core in comments:

Normally when Haskell's typechecker infers a type signature it places all quantifiers of type variables at the outermost position such that no quantifiers appear within the body of the type expression, called the prenex restriction. This restricts an entire class of type signatures that would otherwise be expressible within System-F, but has the benefit of making inference much easier.

loosens the prenex restriction such that we may explicitly place quantifiers within the body of the type. The bad news is that the general problem of inference in this relaxed system is undecidable in general, so we're required to explicitly annotate functions which use RankNTypes or they are otherwise inferred as rank 1 and may not typecheck at all.

Of important note is that the type variables bound by an explicit quantifier in a higher ranked type may not escape their enclosing scope. The typechecker will explicitly enforce this by enforcing that variables bound inside of rank-n types (called skolem constants) will not unify with free meta type variables inferred by the inference engine.

In this example in order for the expression to be well typed, would necessarily have ( ) which implies that over the whole type, but since is bound under the quantifier it must not be unified with and so the typechecker must fail with a skolem capture error.

This can actually be used for our advantage to enforce several types of invariants about scope and use of specific type variables. For example the ST monad uses a second rank type to prevent the capture of references between ST monads with separate state threads where the type variable is bound within a rank-2 type and cannot escape, statically guaranteeing that the implementation details of the ST internals can't leak out and thus ensuring its referential transparency.

An existential type is a pair of a type and a term with a special set of packing and unpacking semantics. The type of the value encoded in the existential is known by the producer but not by the consumer of the existential value.

The existential over gathers a collection of values defined purely in terms of their Show interface and an opaque pointer, no other information is available about the values and they can't be accessed or unpacked in any other way.

Passing around existential types allows us to hide information from consumers of data types and restrict the behavior that functions can use. Passing records around with existential variables allows a type to be "bundled" with a fixed set of functions that operate over its hidden internals.

Although extremely brittle, GHC also has limited support for impredicative polymorphism which allows instantiating type variable with a polymorphic type. Implied is that this loosens the restriction that quantifiers must precede arrow types and now they may be placed inside of type-constructors.

Use of this extension is very rare, and there is some consideration that is fundamentally broken. Although GHC is very liberal about telling us to enable it when one accidentally makes a typo in a type signature!

Some notable trivia, the operator is wired into GHC in a very special way as to allow impredicative instantiation of to be applied via by special-casing the operator only when used for the ST monad. If this sounds like an ugly hack it's because it is, but a rather convenient hack.

For example if we define a function which should behave identically to we'll get an error about polymorphic instantiation even though they are defined identically!

Normally the type variables used within the toplevel signature for a function are only scoped to the type-signature and not the body of the function and its rigid signatures over terms and let/where clauses. Enabling loosens this restriction allowing the type variables mentioned in the toplevel to be scoped within the value-level body of a function and all signatures contained therein.

Generalized Algebraic Data types (GADTs) are an extension to algebraic datatypes that allow us to qualify the constructors to datatypes with type equality constraints, allowing a class of types that are not expressible using vanilla ADTs.

implicitly enables an alternative syntax for datatype declarations ( ) such that the following declarations are equivalent:

For an example use consider the data type , we have a term in which we which takes a parameterized by which span all types. Problems arise between the clash whether ( ) or ( ) when trying to write the evaluator.

And we admit the construction of meaningless terms which forces more error handling cases.

Using a GADT we can express the type invariants for our language (i.e. only type-safe expressions are representable). Pattern matching on this GADTs then carries type equality constraints without the need for explicit tags.

Explicit equality constraints ( ) can be added to a function's context. For example the following expand out to the same types.

This is effectively the implementation detail of what GHC is doing behind the scenes to implement GADTs ( implicitly passing and threading equality terms around ). If we wanted we could do the same setup that GHC does just using equality constraints and existential quantification. Indeed, the internal representation of GADTs is as regular algebraic datatypes that carry coercion evidence as arguments.

In the presence of GADTs inference becomes intractable in many cases, often requiring an explicit annotation. For example can either have or and neither is principal.

Haskell's kind system (i.e. the "type of the types") is a system consisting the single kind and an arrow kind .

There are in fact some extensions to this system that will be covered later ( see: PolyKinds and Unboxed types in later sections ) but most kinds in everyday code are simply either stars or arrows.

With the KindSignatures extension enabled we can now annotate top level type signatures with their explicit kinds, bypassing the normal kind inference procedures.

On top of default GADT declaration we can also constrain the parameters of the GADT to specific kinds. For basic usage Haskell's kind inference can deduce this reasonably well, but combined with some other type system extensions that extend the kind system this becomes essential.

The Void type is the type with no inhabitants. It unifies only with itself.

Using a newtype wrapper we can create a type where recursion makes it impossible to construct an inhabitant.

Or using we can also construct the uninhabited type equivalently as a data declaration with no constructors.

The only inhabitant of both of these types is a diverging term like ( ).

Phantom types are parameters that appear on the left hand side of a type declaration but which are not constrained by the values of the types inhabitants. They are effectively slots for us to encode additional information at the type-level.

Notice the type variable does not appear in the right hand side of the declaration. Using this allows us to express invariants at the type-level that need not manifest at the value-level. We're effectively programming by adding extra information at the type-level.

Consider the case of using newtypes to statically distinguish between plaintext and cryptotext.

Using phantom types we use an extra parameter.

Using can be a powerful combination with phantom types that contain no value inhabitants and are "anonymous types".

With a richer language for datatypes we can express terms that witness the relationship between terms in the constructors, for example we can now express a term which expresses propositional equality between two types.

The type is a proof that types and are equal, by pattern matching on the single constructor we introduce the equality constraint into the body of the pattern match.

As of GHC 7.8 these constructors and functions are included in the Prelude in the Data.Type.Equality module.

The lambda calculus forms the theoretical and practical foundation for many languages. At the heart of every calculus is three components:

There are many different ways of modeling these constructions and data structure representations, but they all more or less contain these three elements. For example, a lambda calculus that uses String names on lambda binders and variables might be written like the following:

A lambda expression in which all variables that appear in the body of the expression are referenced in an outer lambda binder is said to be closed while an expression with unbound free variables is open.

Higher Order Abstract Syntax (HOAS) is a technique for implementing the lambda calculus in a language where the binders of the lambda expression map directly onto lambda binders of the host language ( i.e. Haskell ) to give us substitution machinery in our custom language by exploiting Haskell's implementation.

Pretty printing HOAS terms can also be quite complicated since the body of the function is under a Haskell lambda binder.

A slightly different form of HOAS called PHOAS uses lambda datatype parameterized over the binder type. In this form evaluation requires unpacking into a separate Value type to wrap the lambda expression.

Using typeclasses we can implement a final interpreter which models a set of extensible terms using functions bound to typeclasses rather than data constructors. Instances of the typeclass form interpreters over these terms.

For example we can write a small language that includes basic arithmetic, and then retroactively extend our expression language with a multiplication operator without changing the base. At the same time our interpreter logic remains invariant under extension with new expressions.

Writing an evaluator for the lambda calculus can likewise also be modeled with a final interpreter and a Identity functor.

The usual hand-wavy of describing algebraic datatypes is to indicate the how natural correspondence between sum types, product types, and polynomial expressions arises.

Intuitively it follows the notion that the cardinality of set of inhabitants of a type can always be given as a function of the number of its holes. A product type admits a number of inhabitants as a function of the product (i.e. cardinality of the Cartesian product), a sum type as the sum of its holes and a function type as the exponential of the span of the domain and codomain.

Recursive types are correspond to infinite series of these terms.

See: Species and Functors and Types, Oh My!

The initial algebra approach differs from the final interpreter approach in that we now represent our terms as algebraic datatypes and the interpreter implements recursion and evaluation occurs through pattern matching.

In Haskell a F-algebra is a functor together with a function . A coalgebra reverses the function. For a functor we can form its recursive unrolling using the recursive newtype wrapper.

In this form we can write down a generalized fold/unfold function that are datatype generic and written purely in terms of the recursing under the functor.

We call these functions catamorphisms and anamorphisms. Notice especially that the types of these two functions simply reverse the direction of arrows. Interpreted in another way they transform an algebra/coalgebra which defines a flat structure-preserving mapping between into a function which either rolls or unrolls the fixpoint. What is particularly nice about this approach is that the recursion is abstracted away inside the functor definition and we are free to just implement the flat transformation logic!

For example a construction of the natural numbers in this form:

Or for example an interpreter for a small expression language that depends on a scoping dictionary.

What's especially nice about this approach is how naturally catamorphisms compose into efficient composite transformations.

The code from the F-algebra examples above is implemented in an off-the-shelf library called .

An example of usage:

GHC itself can actually interpret arbitrary Haskell source on the fly by hooking into the GHC's bytecode interpreter ( the same used for GHCi ). The hint package allows us to parse, typecheck, and evaluate arbitrary strings into arbitrary Haskell programs and evaluate them.

This is generally not a wise thing to build a library around, unless of course the purpose of the program is itself to evaluate arbitrary Haskell code ( something like an online Haskell shell or the likes ).

Both hint and mueval do effectively the same task, designed around slightly different internals of the GHC Api.

Contrary to a lot of misinformation, unit testing in Haskell is quite common and robust. Although generally speaking unit tests tend to be of less importance in Haskell since the type system makes an enormous amount of invalid programs completely inexpressible by construction. Unit tests tend to be written later in the development lifecycle and generally tend to be about the core logic of the program and not the intermediate plumbing.

A prominent school of thought on Haskell library design tends to favor constructing programs built around strong equation laws which guarantee strong invariants about program behavior under composition. Many of the testing tools are built around this style of design.

Probably the most famous Haskell library, QuickCheck is a testing framework for generating large random tests for arbitrary functions automatically based on the types of their arguments.

The test data generator can be extended with custom types and refined with predicates that restrict the domain of cases to test.

See: QuickCheck: An Automatic Testing Tool for Haskell

Like QuickCheck, SmallCheck is a property testing system but instead of producing random arbitrary test data it instead enumerates a deterministic series of test data to a fixed depth.

It is useful to generate test cases over all possible inputs of a program up to some depth.

Just like for QuickCheck we can implement series instances for our custom datatypes. For example there is no default instance for Vector, so let's implement one:

SmallCheck can also use Generics to derive Serial instances, for example to enumerate all trees of a certain depth we might use:

Using the QuickCheck arbitrary machinery we can also rather remarkably enumerate a large number of combinations of functions to try and deduce algebraic laws from trying out inputs for small cases.

Of course the fundamental limitation of this approach is that a function may not exhibit any interesting properties for small cases or for simple function compositions. So in general case this approach won't work, but practically it still quite useful.

Running this we rather see it is able to deduce most of the laws for list functions.

Keep in mind the rather remarkable fact that this is all deduced automatically from the types alone!

Criterion can also generate a HTML page containing the benchmark results plotted

Tasty combines all of the testing frameworks into a common API for forming runnable batches of tests and collecting the results.

Often in the process of testing IO heavy code we'll need to redirect stdout to compare it some known quantity. The package allows us to capture anything done to stdout across any library inside of IO block and return the result to the test runner.

Resolution of vanilla Haskell 98 typeclasses proceeds via very simple context reduction that minimizes interdependency between predicates, resolves superclasses, and reduces the types to head normal form. For example:

If a single parameter typeclass expresses a property of a type ( i.e. it's in a class or not in class ) then a multiparameter typeclass expresses relationships between types. For example if we wanted to express the relation a type can be converted to another type we might use a class like:

Of course now our instances for are not unique anymore, so there no longer exists a nice procedure for determining the inferred type of from just . To remedy this let's add a functional dependency , which tells GHC that an instance uniquely determines the instance that b can be. So we'll see that our two instances relating to both and conflict.

Now there's a simpler procedure for determining instances uniquely and multiparameter typeclasses become more usable and inferable again. Effectively a functional dependency says that we can't define multiple multiparamater typeclass instances with the same but different .

Now let's make things not so simple. Turning on loosens the constraint on context reduction that can only allow constraints of the class to become structural smaller than its head. As a result implicit computation can now occur within in the type class instance search. Combined with a type-level representation of Peano numbers we find that we can encode basic arithmetic at the type-level.

If the typeclass contexts look similar to Prolog you're not wrong, if one reads the contexts qualifier backwards as turnstiles then it's precisely the same equations.

This is kind of abusing typeclasses and if used carelessly it can fail to terminate or overflow at compile-time. shouldn't be turned on without careful forethought about what it implies.

Type families allows us to write functions in the type domain which take types as arguments which can yield either types or values indexed on their arguments which are evaluated at compile-time in during typechecking. Type families come in two varieties: data families and type synonym families.

First let's look at type synonym families, there are two equivalent syntactic ways of constructing them. Either as associated type families declared within a typeclass or as standalone declarations at the toplevel. The following forms are semantically equivalent, although the unassociated form is strictly more general:

Using the same example we used for multiparameter + functional dependencies illustration we see that there is a direct translation between the type family approach and functional dependencies. These two approaches have the same expressive power.

An associated type family can be queried using the command in GHCi.

Data families on the other hand allow us to create new type parameterized data constructors. Normally we can only define typeclasses functions whose behavior results in a uniform result which is purely a result of the typeclasses arguments. With data families we can allow specialized behavior indexed on the type.

For example if we wanted to create more complicated vector structures ( bit-masked vectors, vectors of tuples, ... ) that exposed a uniform API but internally handled the differences in their data layout we can use data families to accomplish this:

The type level functions defined by type-families are not necessarily injective, the function may map two distinct input types to the same output type. This differs from the behavior of type constructors ( which are also type-level functions ) which are injective.

For example for the constructor , implies that .

Roles are a further level of specification for type variables parameters of datatypes.

They were added to the language to address a rather nasty and long-standing bug around the correspondence between a newtype and its runtime representation. The fundamental distinction that roles introduce is there are two notions of type equality. Two types are nominally equal when they have the same name. This is the usual equality in Haskell or Core. Two types are representationally equal when they have the same representation. (If a type is higher-kinded, all nominally equal instantiations lead to representationally equal types.)

Roles are normally inferred automatically, but with the extension they can be manually annotated. Except in rare cases this should not be necessary although it is helpful to know what is going on under the hood.

Using type families, mono-traversable generalizes the notion of Functor, Foldable, and Traversable to include both monomorphic and polymorphic types.

For example the text type normally does not admit any of these type-classes since, but now we can write down the instances that model the interface of Foldable and Traversable.

See: From Semigroups to Monads

Rather than having degenerate (and often partial) cases of many of the Prelude functions to accommodate the null case of lists, it is sometimes preferable to statically enforce empty lists from even being constructed as an inhabitant of a type.

In GHC 7.8 can be used to avoid the extraneous and conversions.

One of most deep results in computer science, the Curryâ€“Howard correspondence, is the relation that logical propositions can be modeled by types and instantiating those types constitute proofs of these propositions. Programs are proofs and proofs are programs.

In dependently typed languages we can exploit this result to its full extent, in Haskell we don't have the strength that dependent types provide but can still prove trivial results. For example, now we can model a type level function for addition and provide a small proof that zero is an additive identity.

Translated into Haskell our axioms are simply type definitions and recursing over the inductive datatype constitutes the inductive step of our proof.

Using the extension we can also use infix notation at the type-level.

GHC's implementation also exposes the predicates that bound quantifiers in Haskell as types themselves, with the extension enabled. Using this extension we work with constraints as first class types.

The empty constraint set is indicated by .

For a contrived example if we wanted to create a generic class that carried with it constraints on the elements of the container in question we could achieve this quite simply using type families.

One use-case of this is to capture the typeclass dictionary constrained by a function and reify it as a value.

Type families historically have not been injective, i.e. they are not guaranteed to maps distinct elements of its arguments to the same element of its result. The syntax is similar to the multiparmater typeclass functional dependencies in that the resulting type is uniquely determined by a set of the type families parameters.

The kind system in Haskell is unique by contrast with most other languages in that it allows datatypes to be constructed which take types and type constructor to other types. Such a system is said to support higher kinded types.

All kind annotations in Haskell necessarily result in a kind although any terms to the left may be higher-kinded ( ).

The common example is the Monad which has kind . But we have also seen this higher-kindedness in free monads.

For instance for some monokinded type models a non-empty list with .

The regular value level function which takes a function and applies it to an argument is universally generalized over in the usual Hindley-Milner way.

But when we do the same thing at the type-level we see we lose information about the polymorphism of the constructor applied.

Turning on allows polymorphic variables at the kind level as well.

Using the polykinded type allows us to write down type class functions over constructors of arbitrary kind arity.

For example we can write down the polymorphic combinators at the type level now.

The extension allows us to use refer to constructors at the value level and the type level. Consider a simple sum type:

With the extension enabled we see that our type constructors are now automatically promoted so that or can be viewed as both a data constructor of the type or as the type with kind .

Promoted data constructors can referred to in type signatures by prefixing them with a single quote. Also of importance is that these promoted constructors are not exported with a module by default, but type synonym instances can be created for the ticked promoted types and exported directly.

Combining this with type families we see we can write meaningful, meaningful type-level functions by lifting types to the kind level.

Using this new structure we can create a type which is parameterized by its length as well as its element type now that we have a kind language rich enough to encode the successor type in the kind signature of the generalized algebraic datatype.

So now if we try to zip two types with the wrong shape then we get an error at compile-time about the off-by-one error.

The same technique we can use to create a container which is statically indexed by an empty or non-empty flag, such that if we try to take the head of an empty list we'll get a compile-time error, or stated equivalently we have an obligation to prove to the compiler that the argument we hand to the head function is non-empty.

GHC's type literals can also be used in place of explicit Peano arithmetic.

GHC 7.6 is very conservative about performing reduction, GHC 7.8 is much less so and will can solve many typelevel constraints involving natural numbers but sometimes still needs a little coaxing.

As of GHC 8.0 we have the capacity to provide custom type error using type families. The messages themselves hook into GHC and expressed using the small datatype found in

If one of these expressions is found in the signature of an expression GHC reports an error message of the form:

A less contrived example would be creating a type-safe embedded DSL that enforces invariants about the semantics at the type-level. We've been able to do this sort of thing using GADTs and type-families for a while but the error reporting has been horrible. With 8.0 we can have type-families that emit useful type errors that reflect what actually goes wrong and integrate this inside of GHC.

Continuing with the theme of building more elaborate proofs in Haskell, GHC 7.8 recently shipped with the module which provides us with an extended set of type-level operations for expressing the equality of types as values, constraints, and promoted booleans.

With this we have a much stronger language for writing restrictions that can be checked at a compile-time, and a mechanism that will later allow us to write more advanced proofs.

Using kind polymorphism with phantom types allows us to express the Proxy type which is inhabited by a single constructor with no arguments but with a polykinded phantom type variable which carries an arbitrary type.

In cases where we'd normally pass around a as a witness of a typeclass dictionary, we can instead pass a Proxy object which carries the phantom type without the need for the bottom. Using scoped type variables we can then operate with the phantom paramater and manipulate wherever is needed.

We've seen constructors promoted using DataKinds, but just like at the value-level GHC also allows us some syntactic sugar for list and tuples instead of explicit cons'ing and pair'ing. This is enabled with the extension, which introduces list syntax and tuples of arbitrary arity at the type-level.

Using this we can construct all variety of composite type-level objects.

A singleton type is a type with a single value inhabitant. Singleton types can be constructed in a variety of ways using GADTs or with data families.

Singleton types are an integral part of the small cottage industry of faking dependent types in Haskell, i.e. constructing types with terms predicated upon values. Singleton types are a way of "cheating" by modeling the map between types and values as a structural property of the type.

The builtin singleton types provided in have the useful implementation that type-level values can be reflected to the value-level and back up to the type-level, albeit under an existential.

In the type families we've used so far (called open type families) there is no notion of ordering of the equations involved in the type-level function. The type family can be extended at any point in the code resolution simply proceeds sequentially through the available definitions. Closed type-families allow an alternative declaration that allows for a base case for the resolution allowing us to actually write recursive functions over types.

For example consider if we wanted to write a function which counts the arguments in the type of a function and reifies at the value-level.

The variety of functions we can now write down are rather remarkable, allowing us to write meaningful logic at the type level.

The results of type family functions need not necessarily be kinded as either. For example using Nat or Constraint is permitted.

Just as typeclasses are normally indexed on types, type families can also be indexed on kinds with the kinds given as explicit kind signatures on type variables.

Since record is fundamentally no different from the tuple we can also do the same kind of construction over record field names.

Notably this approach is mostly just all boilerplate class instantiation which could be abstracted away using TemplateHaskell or a Generic deriving.

A heterogeneous list is a cons list whose type statically encodes the ordered types of its values.

Of course this immediately begs the question of how to print such a list out to a string in the presence of type-heterogeneity. In this case we can use type-families combined with constraint kinds to apply the Show over the HLists parameters to generate the aggregate constraint that all types in the HList are Showable, and then derive the Show instance.

Much of this discussion of promotion begs the question whether we can create data structures at the type-level to store information at compile-time. For example a type-level association list can be used to model a map between type-level symbols and any other promotable types. Together with type-families we can write down type-level traversal and lookup functions.

If we ask GHC to expand out the type signature we can view the explicit implementation of the type-level map lookup function.

Now that we have the length-indexed vector let's go write the reverse function, how hard could it be?

So we go and write down something like this:

Running this we find that GHC is unhappy about two lines in the code:

As we unfold elements out of the vector we'll end up doing a lot of type-level arithmetic over indices as we combine the subparts of the vector backwards, but as a consequence we find that GHC will run into some unification errors because it doesn't know about basic arithmetic properties of the natural numbers. Namely that and . Which of course it really shouldn't be given that we've constructed a system at the type-level which intuitively models arithmetic but GHC is just a dumb compiler, it can't automatically deduce the isomorphism between natural numbers and Peano numbers.

So at each of these call sites we now have a proof obligation to construct proof terms. Recall from our discussion of propositional equality from GADTs that we actually have such machinery to construct this now.

One might consider whether we could avoid using the singleton trick and just use type-level natural numbers, and technically this approach should be feasible although it seems that the natural number solver in GHC 7.8 can decide some properties but not the ones needed to complete the natural number proofs for the reverse functions.

Caveat should be that there might be a way to do this in GHC 7.6 that I'm not aware of. In GHC 7.10 there are some planned changes to solver that should be able to resolve these issues. In particular there are plans to allow pluggable type system extensions that could outsource these kind of problems to third party SMT solvers which can solve these kind of numeric relations and return this information back to GHC's typechecker.

As an aside this is a direct transliteration of the equivalent proof in Agda, which is accomplished via the same method but without the song and dance to get around the lack of dependent types.

LiquidHaskell is an extension to GHC's typesystem that adds the capactity for refinement types using the annotation syntax. The type signatures of functions can be checked by the external for richer type semantics than default GHC provides, including non-exhaustive patterns and complex arithemtic properties that require external SMT solvers to verify. For instance LiquidHaskell can statically verify that a function that operates over a is always given a or that an arithmetic functions always yields an Int that is even positive number.

To Install LiquidHaskell in Ubuntu add the following line to your :

And then install the external SMT solver.

Then clone the repo and build it using stack.

Ensure that is on your .

The module can be run through the solver using the command line tool.

For more extensive documentation and further use cases see the official documentation:

Haskell has several techniques for automatic generation of type classes for a variety of tasks that consist largely of boilerplate code generation such as:

These are achieved through several tools and techniques outlined in the next few sections:

The class be used to create runtime type information for arbitrary types.

Using the Typeable instance allows us to write down a type safe cast function which can safely use and provide a proof that the resulting type matches the input.

Of historical note is that writing our own Typeable classes is currently possible of GHC 7.6 but allows us to introduce dangerous behavior that can cause crashes, and shouldn't be done except by GHC itself. As of 7.8 GHC forbids hand-written Typeable instances. As of 7.10 is enabled by default.

See: Typeable and Data in Haskell

Since we have a way of querying runtime type information we can use this machinery to implement a type. This allows us to box up any monotype into a uniform type that can be passed to any function taking a Dynamic type which can then unpack the underlying value in a type-safe way.

In GHC 7.8 the Typeable class is poly-kinded so polymorphic functions can be applied over functions and higher kinded types.

Just as Typeable lets us create runtime type information, the Data class allows us to reflect information about the structure of datatypes to runtime as needed.

The types for and are a little intimidating ( and depend on ), the best way to understand is to look at some examples. First the most trivial case a simple sum type would produce the following code:

For a type with non-empty containers we get something a little more interesting. Consider the list type:

Looking at we see the Data has an implementation of a function for us to walk an applicative over the elements of the constructor by applying a function over each element and applying at the spine. For example look at the instance for a 2-tuple as well:

This is pretty neat, now within the same typeclass we have a generic way to introspect any instance and write logic that depends on the structure and types of its subterms. We can now write a function which allows us to traverse an arbitrary instance of Data and twiddle values based on pattern matching on the runtime types. So let's write down a function which increments a type for both for n-tuples and lists.

We can also write generic operations, for example to count the number of parameters in a data type.

Using the interface provided by the Data we can retrieve the information we need to, at runtime, inspect the types of expressions and rewrite them, collect terms, and find subterms matching specific predicates.

For example consider we have some custom collection of datatypes for which we want to write generic transformations that transform numerical subexpressions according to set of rewrite rules. We can use to write the transformation rules quite succinctly.

The most modern method of doing generic programming uses type families to achieve a better method of deriving the structural properties of arbitrary type classes. Generic implements a typeclass with an associated type ( Representation ) together with a pair of functions that form a 2-sided inverse ( isomorphism ) for converting to and from the associated type and the derived type in question.

GHC.Generics defines a set of named types for modeling the various structural properties of types in available in Haskell.

Using the deriving mechanics GHC can generate this Generic instance for us mechanically, if we were to write it by hand for a simple type it might look like this:

Use in GHCi we can look at the type family associated with a Generic instance.

Now the clever bit, instead writing our generic function over the datatype we instead write it over the Rep and then reify the result using . So for an equivalent version of Haskell's default that instead uses generic deriving we could write:

To accommodate the two methods of writing classes (generic-deriving or custom implementations) we can use the extension to allow the user to leave typeclass functions blank and defer to Generic or to define their own.

Now anyone using our library need only derive Generic and create an empty instance of our typeclass instance without writing any boilerplate for .

Here is a complete example for deriving equality generics:

Using Generics many common libraries provide a mechanisms to derive common typeclass instances. Some real world examples:

The hashable library allows us to derive hashing functions.

The cereal library allows us to automatically derive a binary representation.

The aeson library allows us to derive JSON representations for JSON instances.

Using the same interface GHC.Generics provides a separate typeclass for higher-kinded generics.

So for instance has of the form:

Uniplate is a generics library for writing traversals and transformation for arbitrary data structures. It is extremely useful for writing AST transformations and rewriting systems.

The function will apply a function to each immediate descendant of an expression and then combines them up into the parent expression.

The function will perform a single pass bottom-up transformation of all terms in the expression.

The function will perform an exhaustive transformation of all terms in the expression to fixed point, using Maybe to signify termination.

Alternatively Uniplate instances can be derived automatically from instances of Data without the need to explicitly write a Uniplate instance. This approach carries a slight amount of overhead over an explicit hand-written instance.

Biplates generalize plates where the target type isn't necessarily the same as the source, it uses multiparameter typeclasses to indicate the type sub of the sub-target. The Uniplate functions all have an equivalent generalized biplate form.

Haskell's numeric tower is unusual and the source of some confusion for novices. Haskell is one of the few languages to incorporate statically typed overloaded literals without a mechanism for "coercions" often found in other languages.

To add to the confusion numerical literals in Haskell are desugared into a function from a numeric typeclass which yields a polymorphic value that can be instantiated to any instance of the or typeclass at the call-site, depending on the inferred type.

To use a blunt metaphor, we're effectively placing an object in a hole and the size and shape of the hole defines the object you place there. This is very different than in other languages where a numeric literal like is hard coded in the compiler to be a specific type ( double or something ) and you cast the value at runtime to be something smaller or larger as needed.

The numeric typeclass hierarchy is defined as such:

Conversions between concrete numeric types ( from : left column, to : top row ) is accomplished with several generic functions.

The type in GHC is implemented by the GMP ( ) arbitrary precision arithmetic library. Unlike the type the size of Integer values is bounded only by the available memory. Most notably is one of the few libraries that compiled Haskell binaries are dynamically linked against.

An alternative library can be linked in place of libgmp.

Haskell supports arithmetic with complex numbers via a Complex datatype from the module. The first argument is the real part, while the second is the imaginary part. The type has a single parameter and inherits it's numerical typeclass components (Num, Fractional, Floating) from the type of this paramater.

The instance for is only defined if parameter of is an instance of .

Scientific provides arbitrary-precision numbers represented using scientific notation. The constructor takes an arbitrarily sized Integer argument for the digits and an Int for the exponent. Alternatively the value can be parsed from a String or coerced from either Double/Float.

Instead of modeling the real numbers on finite precision floating point numbers we alternatively work with which internally manipulate the power series expansions for the expressions when performing operations like arithmetic or transcendental functions without losing precision when performing intermediate computations. Then we simply slice off a fixed number of terms and approximate the resulting number to a desired precision. This approach is not without its limitations and caveats ( notably that it may diverge ).

A collection of constraint problems known as satisfiability problems show up in a number of different disciplines from type checking to package management. Simply put a satisfiability problem attempts to find solutions to a statement of conjoined conjunctions and disjunctions in terms of a series of variables. For example:

To use the picosat library to solve this, it can be written as zero-terminated lists of integers and fed to the solver according to a number-to-variable relation:

The SAT solver itself can be used to solve satisfiability problems with millions of variables in this form and is finely tuned.

A generalization of the SAT problem to include predicates other theories gives rise to the very sophisticated domain of "Satisfiability Modulo Theory" problems. The existing SMT solvers are very sophisticated projects ( usually bankrolled by large institutions ) and usually have to called out to via foreign function interface or via a common interface called SMT-lib. The two most common of use in Haskell are from Stanford and from Microsoft Research.

The SBV library can abstract over different SMT solvers to allow us to express the problem in an embedded domain language in Haskell and then offload the solving work to the third party library.

As an example, here's how you can solve a simple cryptarithm

Let's look at all possible solutions,

A map is an associative array mapping any instance of keys to values of any type.

Sets are an unordered data structures allow values of any type and guaranteeing uniqueness with in the structure. They are not identical to the mathematical notion of a Set even though they share the same namesake.

Vectors are high performance single dimensional arrays that come come in six variants, two for each of the following types of a mutable and an immutable variant.

The most notable feature of vectors is constant time memory access with ( ) as well as variety of efficient map, fold and scan operations on top of a fusion framework that generates surprisingly optimal code.

Within the IO monad we can perform arbitrary read and writes on the mutable vector with constant time reads and writes. When needed a static Vector can be created to/from the using the freeze/thaw functions.

The vector library itself normally does bounds checks on index operations to protect against memory corruption. This can be enabled or disabled on the library level by compiling with cabal flag.

Both the and are purely functional data structures that are drop in replacements for the equivalents but with more efficient space and time performance. Additionally all stored elements must have a instance.

Hashtables provides hashtables with efficient lookup within the ST or IO monad.

The Graph module in the containers library is a somewhat antiquated API for working with directed graphs. A little bit of data wrapping makes it a little more straightforward to use. The library is not necessarily well-suited for large graph-theoretic operations but is perfectly fine for example, to use in a typechecker which need to resolve strongly connected components of the module definition graph.

So for example we can construct a simple graph:

Or with two strongly connected subgraphs:

The library provides a more efficient graph structure and a wide variety of common graph-theoretic operations. For example calculating the dominance frontier of a graph shows up quite frequently in control flow analysis for compiler design.

A dlist is a list-like structure that is optimized for O(1) append operations, internally it uses a Church encoding of the list structure. It is specifically suited for operations which are append-only and need only access it when manifesting the entire structure. It is particularly well-suited for use in the Writer monad.

The sequence data structure behaves structurally similar to list but is optimized for append/prepend operations and traversal.

Wrapping pure C functions with primitive types is trivial.

There exists a typeclass that can be used to provide low-level access to the memory underlying Haskell values. objects in Haskell behave much like C pointers although arithmetic with them is in terms of bytes only, not the size of the type associated with the pointer ( this differs from C).

The Prelude defines Storable interfaces for most of the basic types as well as types in the library.

To pass arrays from Haskell to C we can again use Storable Vector and several unsafe operations to grab a foreign pointer to the underlying data that can be handed off to C. Once we're in C land, nothing will protect us from doing evil things to memory!

The names of foreign functions from a C specific header file can be qualified.

Prepending the function name with a allows us to create a reference to the function pointer itself.

Using the above FFI functionality, it's trivial to pass C function pointers into Haskell, but what about the inverse passing a function pointer to a Haskell function into C using .

Will yield the following output:

The definitive reference on concurrency and parallelism in Haskell is Simon Marlow's text. This will section will just gloss over these topics because they are far better explained in this book.

See: Parallel and Concurrent Programming in Haskell

Haskell threads are extremely cheap to spawn, using only 1.5KB of RAM depending on the platform and are much cheaper than a pthread in C. Calling forkIO 106 times completes just short of a 1s. Additionally, functional purity in Haskell also guarantees that a thread can almost always be terminated even in the middle of a computation without concern.

The most basic "atom" of parallelism in Haskell is a spark. It is a hint to the GHC runtime that a computation can be evaluated to weak head normal form in parallel.

spins off a separate spark that evolutes a to weak head normal form and places the computation in the spark pool. When the runtime determines that there is an available CPU to evaluate the computation it will evaluate ( convert ) the spark. If the main thread of the program is the evaluator for the spark, the spark is said to have fizzled. Fizzling is generally bad and indicates that the logic or parallelism strategy is not well suited to the work that is being evaluated.

The spark pool is also limited ( but user-adjustable ) to a default of 8000 (as of GHC 7.8.3 ). Sparks that are created beyond that limit are said to overflow.

An argument to forces the evaluation of a spark before evaluation continues.

The parallel runtime is necessary to use sparks, and the resulting program must be compiled with . Additionally the program itself can be specified to take runtime options with such as the number of cores to use.

The runtime can be asked to dump information about the spark evaluation by passing the flag.

The parallel computations themselves are sequenced in the monad, whose evaluation with is itself a pure computation.

Passing the flag generates the eventlog which can be rendered with the threadscope library.

See Simon Marlows's Parallel and Concurrent Programming in Haskell for a detailed guide on interpreting and profiling using Threadscope.

Sparks themselves form the foundation for higher level parallelism constructs known as which adapt spark creation to fit the computation or data structure being evaluated. For instance if we wanted to evaluate both elements of a tuple in parallel we can create a strategy which uses sparks to evaluate both sides of the tuple.

This pattern occurs so frequently the combinator can be used to write it equivalently in operator-like form that may be more visually appealing to some.

For a less contrived example consider a parallel which maps a pure function over a list of a values in parallel.

The functions above are quite useful, but will break down if evaluation of the arguments needs to be parallelized beyond simply weak head normal form. For instance if the arguments to is a nested constructor we'd like to parallelize the entire section of work in evaluated the expression to normal form instead of just the outer layer. As such we'd like to generalize our strategies so the the evaluation strategy for the arguments can be passed as an argument to the strategy.

contains a generalized version of which embeds additional evaluation logic inside the computation in Eval monad.

Using the deepseq library we can now construct a Strategy variant of rseq that evaluates to full normal form.

We now can create a "higher order" strategy that takes two strategies and itself yields a a computation which when evaluated uses the passed strategies in its scheduling.

These patterns are implemented in the Strategies library along with several other general forms and combinators for combining strategies to fit many different parallel computations.

Software Transactional Memory is a technique for guaranteeing atomicity of values in parallel computations, such that all contexts view the same data when read and writes are guaranteed never to result in inconsistent states.

The strength of Haskell's purity guarantees that transactions within STM are pure and can always be rolled back if a commit fails.

Using the Par monad we express our computation as a data flow graph which is scheduled in order of the connections between forked computations which exchange resulting computations with .

Async is a higher level set of functions that work on top of Control.Concurrent and STM.

Diagrams is a a parser combinator library for generating vector images to SVG and a variety of other formats.

For parsing in Haskell it is quite common to use a family of libraries known as Parser Combinators which let us write code to generate parsers which themselves looks very similar to the parser grammar itself!

There are two styles of writing Parsec, one can choose to write with monads or with applicatives.

The same code written with applicatives uses the applicative combinators:

Now for instance if we want to parse simple lambda expressions we can encode the parser logic as compositions of these combinators which yield the string parser when evaluated under with the .

In our previous example lexing pass was not necessary because each lexeme mapped to a sequential collection of characters in the stream type. If we wanted to extend this parser with a non-trivial set of tokens, then Parsec provides us with a set of functions for defining lexers and integrating these with the parser combinators. The simplest example builds on top of the builtin Parsec language definitions which define a set of most common lexical schemes.

For instance we'll build on top of the empty language grammar on top of the haskellDef grammer that uses the Text token instead of string.

Putting our lexer and parser together we can write down a more robust parser for our little lambda calculus syntax.

Trying it out:

Previously we defined generic operations for pretty printing and this begs the question of whether we can write a parser on top of Generics. The answer is generally yes, so long as there is a direct mapping between the specific lexemes and sum and products types. Consider the simplest case where we just read off the names of the constructors using the regular Generics machinery and then build a Parsec parser terms of them.

With a little more work and an outer wrapper, this example an easily be extended to automate parsing of a simple recursive type.

Attoparsec is a parser combinator like Parsec but more suited for bulk parsing of large text and binary files instead of parsing language syntax to ASTs. When written properly Attoparsec parsers can be efficient.

One notable distinction between Parsec and Attoparsec is that backtracking operator ( ) is not present and reflects on attoparsec's different underlying parser model.

For a simple little lambda calculus language we can use attoparsec much in the same we used parsec:

For an example try the above parser with the following simple lambda expression.

Attoparsec adapts very well to binary and network protocol style parsing as well, this is extracted from a small implementation of a distributed consensus network protocol:

Optparse-applicative is a combinator library for building command line interfaces that take in various user flags, commmands and switches and map them into Haskell data structures that can handle the input. The main interface is through the applicative functor and various combinators such as and which populate the option parsing table with some monadic action which returns a Haskell value. The resulting sequence of values can be combined applicatively into a larger Config data structure that holds all the given options. The header is also automatically generated from the combinators.

Happy is a parser generator system for Haskell, similar to the tool `yacc' for C. It works as a preprocessor with it's own syntax that generates a parse table from two specifications, a lexer file and parser file. Happy does not have the same underlying parser implementation as parser combinators and can effectively work with left-recursive grammars without explicit factorization. It can also easily be modified to track position information for tokens and handle offside parsing rules for indentation-sensitive grammars. Happy is used in GHC itself for Haskell's grammar.

Running the standalone commands will generate the Haskell source for the modules.

The generated modules are not human readable generally and unfortunatly error messages are given in the Haskell source, not the Happy source.

For instance we could define a little toy lexer with a custom set of tokens.

The associated parser is list of a production rules and a monad to running the parser in. Production rules consist of a set of options on the left and generating Haskell expressions on the right with indexed metavariables ( , , ...) mapping to the ordered terms on the left (i.e. in the second term ~ , ~ ).

As a simple input consider the following simple program.

The problem with using the usual monadic approach to processing data accumulated through IO is that the Prelude tools require us to manifest large amounts of data in memory all at once before we can even begin computation.

Reading from the file creates a thunk for the string that forced will then read the file. The problem is then that this method ties the ordering of IO effects to evaluation order which is difficult to reason about in the large.

Consider that normally the monad laws ( in the absence of ) guarantee that these computations should be identical. But using lazy IO we can construct a degenerate case.

So what we need is a system to guarantee deterministic resource handling with constant memory usage. To that end both the Conduits and Pipes libraries solved this problem using different ( though largely equivalent ) approaches.

Pipes is a stream processing library with a strong emphasis on the static semantics of composition. The simplest usage is to connect "pipe" functions with a composition operator, where each component can and to push and pull values along the stream.

For example we could construct a "FizzBuzz" pipe.

To continue with the degenerate case we constructed with Lazy IO, consider than we can now compose and sequence deterministic actions over files without having to worry about effect order.

This is simple a sampling of the functionality of pipes. The documentation for pipes is extensive and great deal of care has been taken make the library extremely thorough. is a shining example of an accessible yet category theoretic driven design.

As a motivating example, ZeroMQ is a network messaging library that abstracts over traditional Unix sockets to a variety of network topologies. Most notably it isn't designed to guarantee any sort of transactional guarantees for delivery or recovery in case of errors so it's necessary to design a layer on top of it to provide the desired behavior at the application layer.

In Haskell we'd like to guarantee that if we're polling on a socket we get messages delivered in a timely fashion or consider the resource in an error state and recover from it. Using we can manage the life cycle of lazy IO resources and can safely handle failures, resource termination and finalization gracefully. In other languages this kind of logic would be smeared across several places, or put in some global context and prone to introduce errors and subtle race conditions. Using pipes we instead get a nice tight abstraction designed exactly to fit this kind of use case.

For instance now we can bracket the ZeroMQ socket creation and finalization within the monad transformer which guarantees that after successful message delivery we execute the pipes function as expected, or on failure we halt the execution and finalize the socket.

Conduits are conceptually similar though philosophically different approach to the same problem of constant space deterministic resource handling for IO resources.

The first initial difference is that await function now returns a which allows different handling of termination. The composition operators are also split into a connecting operator ( ) and a fusing operator ( ) for combining Sources and Sink and a Conduit and a Sink respectively.

Aeson is library for efficient parsing and generating JSON. It is the canonical JSON library for handling JSON.

A point of some subtlety to beginners is that the return types for Aeson functions are polymorphic in their return types meaning that the resulting type of decode is specified only in the context of your programs use of the decode function. So if you use decode in a point your program and bind it to a value and then use as if it were and integer throughout the rest of your program, Aeson will select the typeclass instance which parses the given input string into a Haskell integer.

Aeson uses several high performance data structures (Vector, Text, HashMap) by default instead of the naive versions so typically using Aeson will require that us import them and use when indexing into objects.

The underlying Aeson structure is called and encodes a recursive tree structure that models the semantics of untyped JSON objects by mapping them onto a large sum type which embodies all possible JSON values.

For instance the Value expansion of the following JSON blob:

Is represented in Aeson as the :

Let's consider some larger examples, we'll work with this contrived example JSON:

In dynamic scripting languages it's common to parse amorphous blobs of JSON without any a priori structure and then handle validation problems by throwing exceptions while traversing it. We can do the same using Aeson and the Maybe monad.

This isn't ideal since we've just smeared all the validation logic across our traversal logic instead of separating concerns and handling validation in separate logic. We'd like to describe the structure before-hand and the invalid case separately. Using Generic also allows Haskell to automatically write the serializer and deserializer between our datatype and the JSON string based on the names of record field names.

Now we get our validated JSON wrapped up into a nicely typed Haskell ADT.

The functions and can be used to convert between this sum type and regular Haskell types with.

As of 7.10.2 we can use the new -XDeriveAnyClass to automatically derive instances of FromJSON and TOJSON without the need for standalone instance declarations. These are implemented entirely in terms of the default methods which use Generics under the hood.

While it's useful to use generics to derive instances, sometimes you actually want more fine grained control over serialization and de serialization. So we fall back on writing ToJSON and FromJSON instances manually. Using FromJSON we can project into hashmap using the operator to extract keys. If the key fails to exist the parser will abort with a key failure message. The ToJSON instances can never fail and simply require us to pattern match on our custom datatype and generate an appropriate value.

The law that the FromJSON and ToJSON classes should maintain is that and should map to the same object. Although in practice there many times when we break this rule and especially if the serialize or de serialize is one way.

Yaml is a textual serialization format similar to JSON. It uses an indentation sensitive structure to encode nested maps of keys and values. The Yaml interface for Haskell is a precise copy of

To parse this file we use the following datatypes and functions:

Cassava is an efficient CSV parser library. We'll work with this tiny snippet from the iris dataset:

Just like with Aeson if we really want to work with unstructured data the library accommodates this.

We see we get the nested set of stringy vectors:

Just like with Aeson we can use Generic to automatically write the deserializer between our CSV data and our custom datatype.

And again we get a nice typed ADT as a result.

Haskell has a variety of HTTP request and processing libraries. The simplest and most flexible is the HTTP library.

Blaze is an HTML combinator library that provides that capacity to build composable bits of HTML programmatically. It doesn't string templating libraries like Hastache but instead provides an API for building up HTML documents from logic where the format out of the output is generated procedurally.

For sequencing HTML elements the elements can either be sequenced in a monad or with monoid operations.

For custom datatypes we can implement the class to convert between Haskell data structures and HTML representation.

Warp is a efficient web server, it's the backend request engine behind several of popular Haskell web frameworks. The internals have been finely tuned to utilize Haskell's concurrent runtime and is capable of handling a great deal of concurrent requests.

Continuing with our trek through web libraries, Scotty is a web microframework similar in principle to Flask in Python or Sinatra in Ruby.

Of importance to note is the Blaze library used here overloads do-notation but is not itself a proper monad so the various laws and invariants that normally apply for monads may break down or fail with error terms.

Hastache is string templating based on the "Mustache" style of encoding metavariables with double braces . Hastache supports automatically converting many Haskell types into strings and uses the efficient Text functions for formatting.

The variables loaded into the template are specified in either a function mapping variable names to printable MuType values. For instance using a function.

Or using Data-Typeable record and , the Haskell field names are converted into variable names.

The MuType and MuContext types can be parameterized by any monad or transformer that implements , not just IO.

Postgres is an object-relational database management system with a rich extension of the SQL standard. Consider the following tables specified in DDL.

The postgresql-simple bindings provide a thin wrapper to various libpq commands to interact a Postgres server. These functions all take a object to the database instance and allow various bytestring queries to be sent and result sets mapped into Haskell datatypes. There are four primary functions for these interactions:

The result of the function is a list of elements which implement the FromRow typeclass. This can be many things including a single elemment (Only), a list of tuples where each element implements or a custom datatype that itself implements . Under the hood the database bindings inspects the Postgres objects and then attempts to convert them into the Haskell datatype of the field being scrutinised. This can fail at runtime if the types in the database don't align with the expected types in the logic executing the SQL query.

As SQL expressions grow in complexity they often span multiple lines and sometimes its useful to just drop down to a quasiquoter to embed the whole query. The quoter here is pure, and just generates the object behind as a ByteString.

Redis is an in-memory key-value store with support for a variety of datastructures. The Haskell exposure is exposed in a monad which sequences a set of redis commands taking ByteString arguments and then executes them against a connection object.

Redis is quite often used as a lightweight pubsub server, and the bindings integrate with the Haskell concurrency primitives so that listeners can be sparked and shared across threads off without blocking the main thread.

Acid-state allows us to build a "database" for around our existing Haskell datatypes that guarantees atomic transactions. For example, we can build a simple key-value store wrapped around the Map type.

The flow of code through GHC is a process of translation between several intermediate languages and optimizations and transformations thereof. A common pattern for many of these AST types is they are parametrized over a binder type and at various stages the binders will be transformed, for example the Renamer pass effectively translates the datatype from a AST parametrized over literal strings as the user enters into a parameterized over qualified names that includes modules and package names into a higher level Name type.

Information for each pass can dumped out via a rather large collection of flags. The GHC internals are very accessible although some passes are somewhat easier to understand than others. Most of the time and are sufficient to get an understanding of how the code will compile, unless of course you're dealing with very specialized optimizations or hacking on GHC itself.

Core is the explicitly typed System-F family syntax through that all Haskell constructs can be expressed in.

To inspect the core from GHCi we can invoke it using the following flags and the following shell alias. We have explicitly disable the printing of certain metadata and longform names to make the representation easier to read.

At the interactive prompt we can then explore the core representation interactively:

ghc-core is also very useful for looking at GHC's compilation artifacts.

Alternatively the major stages of the compiler ( parse tree, core, stg, cmm, asm ) can be manually outputted and inspected by passing several flags to the compiler:

Core from GHC is roughly human readable, but it's helpful to look at simple human written examples to get the hang of what's going on.

Machine generated names are created for a lot of transformation of Core. Generally they consist of a prefix and unique identifier. The prefix is often pass specific ( i.e. for desugar generated name s) and sometimes specific names are generated for specific automatically generated code. A list of the common prefixes and their meaning is show below.

Of important note is that the Î› and Î» for type-level and value-level lambda abstraction are represented by the same symbol ( ) in core, which is a simplifying detail of the GHC's implementation but a source of some confusion when starting.

The function has an intuitive implementation in the Core language.

One particularly notable case of the Core desugaring process is that pattern matching on overloaded numbers implicitly translates into equality test (i.e. ).

Of course, adding a concrete type signature changes the desugar just matching on the unboxed values.

Having to enter a secondary closure every time we used would introduce an enormous overhead. Fortunately GHC has a pass to eliminate small functions like this by simply replacing the function call with the body of its definition at appropriate call-sites. The compiler contains a variety of heuristics for determining when this kind of substitution is appropriate and the potential costs involved.

In addition to the automatic inliner, manual pragmas are provided for more granular control over inlining. It's important to note that naive inlining quite often results in significantly worse performance and longer compilation times.

For example the contrived case where we apply a binary function to two arguments. The function body is small and instead of entering another closure just to apply the given function, we could in fact just inline the function application at the call site.

Looking at the core, we can see that in the function has indeed been expanded at the call site and simply performs the addition there instead of another indirection.

Cases marked with generally indicate that the logic in the function is using something like or some other unholy function. In these cases naive inlining might duplicate effects at multiple call-sites throughout the program which would be undesirable.

The Haskell language defines the notion of Typeclasses but is agnostic to how they are implemented in a Haskell compiler. GHC's particular implementation uses a pass called the dictionary passing translation part of the elaboration phase of the typechecker which translates Core functions with typeclass constraints into implicit parameters of which record-like structures containing the function implementations are passed.

This class can be thought as the implementation equivalent to the following parameterized record of functions.

and have simple translation but for monads with existential type variables in their signatures, the only way to represent the equivalent dictionary is using . In addition a typeclass may also include superclasses which would be included in the typeclass dictionary and parameterized over the same arguments and an implicit superclass constructor function is created to pull out functions from the superclass for the current monad.

Indeed this is not that far from how GHC actually implements typeclasses. It elaborates into projection functions and data constructors nearly identical to this, and are expanded out to a dictionary argument for each typeclass constraint of every polymorphic function.

Overloading in Haskell is normally not entirely free by default, although with an optimization called specialization it can be made to have zero cost at specific points in the code where performance is crucial. This is not enabled by default by virtue of the fact that GHC is not a whole-program optimizing compiler and most optimizations ( not all ) stop at module boundaries.

GHC's method of implementing typeclasses means that explicit dictionaries are threaded around implicitly throughout the call sites. This is normally the most natural way to implement this functionality since it preserves separate compilation. A function can be compiled independently of where it is declared, not recompiled at every point in the program where it's called. The dictionary passing allows the caller to thread the implementation logic for the types to the call-site where it can then be used throughout the body of the function.

Of course this means that in order to get at a specific typeclass function we need to project ( possibly multiple times ) into the dictionary structure to pluck out the function reference. The runtime makes this very cheap but not entirely free.

Many C++ compilers or whole program optimizing compilers do the opposite however, they explicitly specialize each and every function at the call site replacing the overloaded function with its type-specific implementation. We can selectively enable this kind of behavior using class specialization.

In the specialized version the typeclass operations placed directly at the call site and are simply unboxed arithmetic. This will map to a tight set of sequential CPU instructions and is very likely the same code generated by C.

The non-specialized version has to project into the typeclass dictionary ( ) 6 times and likely go through around 25 branches to perform the same operation.

For a tight loop over numeric types specializing at the call site can result in orders of magnitude performance increase. Although the cost in compile-time can often be non-trivial and when used function used at many call-sites this can slow GHC's simplifier pass to a crawl.

The best advice is profile and look for large uses of dictionary projection in tight loops and then specialize and inline in these places.

Using the pragma can unintentionally cause GHC to diverge if applied over a recursive function, it will try to specialize itself infinitely.

On Linux, Haskell programs can be compiled into a standalone statically linked binary that includes the runtime statically linked into it.

In addition the file size of the resulting binary can be reduced by stripping unneeded symbols.

upx can additionally be used to compress the size of the executable down further.

The usual numerics types in Haskell can be considered to be a regular algebraic datatype with special constructor arguments for their underlying unboxed values. Normally unboxed types and explicit unboxing are not used in normal code, they are wired-in to the compiler.

An unboxed type with kind and will never unify a type variable of kind . Intuitively a type with kind indicates a type with a uniform runtime representation that can be used polymorphically.

The function for integer arithmetic used in the typeclass for is just pattern matching on this type to reveal the underlying unboxed value, performing the builtin arithmetic and then performing the packing up into again.

Where is a low level function built into GHC that maps to intrinsic integer addition instruction for the CPU.

Runtime values in Haskell are by default represented uniformly by a boxed struct which itself contains several payload values, which can themselves either be pointers to other boxed values or to unboxed literal values that fit within the system word size and are stored directly within the closure in memory. The layout of the box is described by a bitmap in the header for the closure which describes which values in the payload are either pointers or non-pointers.

The primop can be used to extract this information at runtime by reading off the bitmap on the closure.

For example the datatype with the pragma contains 1 non-pointer and 0 pointers.

While the default packed datatype contains 1 pointer and 0 non-pointers.

The closure representation for data constructors are also "tagged" at the runtime with the tag of the specific constructor. This is however not a runtime type tag since there is no way to recover the type from the tag as all constructor simply use the sequence (0, 1, 2, ...). The tag is used to discriminate cases in pattern matching. The builtin can be used to pluck off the tag for an arbitrary datatype. This is used in some cases when desugaring pattern matches.

String literals included in the source code are also translated into several primop operations. The type in Haskell stands for a static contagious buffer pre-allocated on the Haskell heap that can hold a sequence. The operation can scan this buffer and fold it up into a list of Chars from inside Haskell.

This is done in the early frontend desugarer phase, where literals are translated into inline instead of giant chain of Cons'd characters. So our "Hello World" translates into the following Core:

Both the IO and the ST monad have special state in the GHC runtime and share a very similar implementation. Both and are passing around an unboxed tuple of the form:

The token is "deeply magical" and doesn't actually expand into any code when compiled, but simply threaded around through every bind of the IO or ST monad and has several properties of being unique and not being able to be duplicated to ensure sequential IO actions are actually sequential. can thought of as the unique operation which discards the world token and plucks the out, and is as the name implies not normally safe.

The abstracts over both these monads with an associated data family for the world token or ST thread, and can be used to write operations that generic over both ST and IO. This is used extensively inside of the vector package to allow vector algorithms to be written generically either inside of IO or ST.

Through some dark runtime magic we can actually inspect the structures at runtime using various C and Cmm hacks to probe at the fields of the structure's representation to the runtime. The library can be used to introspect such things, although there is really no use for this kind of thing in everyday code it is very helpful when studying the GHC internals to be able to inspect the runtime implementation details and get at the raw bits underlying all Haskell types.

A constructor (in this for cons constructor of list type) is represented by a closure that holds two pointers to the head and the tail. The integer in the head argument is a static reference to the pre-allocated number and we see a single static reference in the SRT (static reference table).

We can also observe the evaluation and update of a thunk in process ( ). The initial thunk is simply a thunk type with a pointer to the code to evaluate it to a value.

When forced it is then evaluated and replaced with an Indirection closure which points at the computed value.

When the copying garbage collector passes over the indirection, it then simply replaces the indirection with a reference to the actual computed value computed by so that future access does need to chase a pointer through the indirection pointer to get the result.

After being compiled into Core, a program is translated into a very similar intermediate form known as STG ( Spineless Tagless G-Machine ) an abstract machine model that makes all laziness explicit. The spineless indicates that function applications in the language do not have a spine of applications of functions are collapsed into a sequence of arguments. Currying is still present in the semantics since arity information is stored and partially applied functions will evaluate differently than saturated functions.

All let statements in STG bind a name to a lambda form. A lambda form with no arguments is a thunk, while a lambda-form with arguments indicates that a closure is to be allocated that captures the variables explicitly mentioned.

Thunks themselves are either reentrant ( ) or updatable ( ) indicating that the thunk and either yields a value to the stack or is allocated on the heap after the update frame is evaluated All subsequent entry's of the thunk will yield the already-computed value without needing to redo the same work.

A lambda form also indicates the static reference table a collection of references to static heap allocated values referred to by the body of the function.

For example turning on we can see the expansion of the following compose function.

For a more sophisticated example, let's trace the compilation of the factorial function.

Notice that the factorial function allocates two thunks ( look for ) inside of the loop which are updated when computed. It also includes static references to both itself (for recursion) and the dictionary for instance of typeclass over the type .

With turned on GHC will perform a special optimization known as the Worker-Wrapper transformation which will split the logic of the factorial function across two definitions, the worker will operate over stack unboxed allocated machine integers which compiles into a tight inner loop while the wrapper calls into the worker and collects the end result of the loop and packages it back up into a boxed heap value. This can often be an order of of magnitude faster than the naive implementation which needs to pack and unpack the boxed integers on every iteration.

The Z-encoding is Haskell's convention for generating names that are safely represented in the compiler target language. Simply put the z-encoding renames many symbolic characters into special sequences of the z character.

In this way we don't have to generate unique unidentifiable names for character rich names and can simply have a straightforward way to translate them into something unique but identifiable.

So for some example names from GHC generated code:

Cmm is GHC's complex internal intermediate representation that maps directly onto the generated code for the compiler target. Cmm code generated from Haskell is CPS-converted, all functions never return a value, they simply call the next frame in the continuation stack. All evaluation of functions proceed by indirectly jumping to a code object with its arguments placed on the stack by the caller.

This is drastically different than C's evaluation model, where are placed on the stack and a function yields a value to the stack after it returns.

There are several common suffixes you'll see used in all closures and function names:

There are 10 registers that described in the machine model. Sp is the pointer to top of the stack, SpLim is the pointer to last element in the stack. Hp is the heap pointer, used for allocation and garbage collection with HpLim the current heap limit.

The R1 register always holds the active closure, and subsequent registers are arguments passed in registers. Functions with more than 10 values spill into memory.

To understand Cmm it is useful to look at the code generated by the equivalent Haskell and slowly understand the equivalence and mechanical translation maps one to the other.

There are generally two parts to every Cmm definition, the info table and the entry code. The info table maps directly struct and contains various fields related to the type of the closure, its payload, and references. The code objects are basic blocks of generated code that correspond to the logic of the Haskell function/constructor.

For the simplest example consider a constant static constructor. Simply a function which yields the Unit value. In this case the function is simply a constructor with no payload, and is statically allocated.

Consider a static constructor with an argument.

Consider a literal constant. This is a static value.

Consider a function where application of a function ( of unknown arity ) occurs.

Consider a function which branches using pattern matching:

Cmm itself uses many macros to stand for various constructs, many of which are defined in an external C header file. A short reference for the common types:

Many of the predefined closures ( , etc) are themselves mechanically generated and more or less share the same form ( a giant switch statement on closure type, update frame, stack adjustment). Inside of GHC is a file named that generates most of these functions. See the Gist link in the reading section for the current source file that GHC generates. For example the output for .

Handwritten Cmm can be included in a module manually by first compiling it through GHC into an object and then using a special FFI invocation.

GHC will place the info table for a toplevel closure directly next to the entry-code for the objects in memory such that the fields from the info table can be accessed by pointer arithmetic on the function pointer to the code itself. Not performing this optimization would involve chasing through one more pointer to get to the info table. Given how often info-tables are accessed using the tables-next-to-code optimization results in a tractable speedup.

Depending on the type of the closure involved, GHC will utilize the last few bits in a pointer to the closure to store information that can be read off from the bits of pointer itself before jumping into or access the info tables. For thunks this can be information like whether it is evaluated to WHNF or not, for constructors it contains the constructor tag (if it fits) to avoid an info table lookup.

Depending on the architecture the tag bits are either the last 2 or 3 bits of a pointer.

These occur in Cmm most frequently via the following macro definitions:

So for instance in many of the precompiled functions, there will be a test for whether the active closure is already evaluated.

During compilation GHC will produce interface files for each module that are the binary encoding of specific symbols (functions, typeclasses, etc) exported by that modules as well as any package dependencies it itself depends on. This is effectively the serialized form of the ModGuts structure used internally in the compiler. The internal structure of this file can be dumped using the flag. The precise structure changes between versions of GHC.

EKG is a monitoring tool that can monitor various aspect of GHC's runtime alongside an active process. The interface for the output is viewable within a browser interface. The monitoring process is forked off (in a system thread) from the main process.

The GHC runtime system can be asked to dump information about allocations and percentage of wall time spent in various portions of the runtime system.

Productivity indicates the amount of time spent during execution compared to the time spent garbage collecting. Well tuned CPU bound programs are often in the 90-99% range of productivity range.

In addition individual function profiling information can be generated by compiling the program with flag. The resulting information is outputted to a file of the same name as the module. This is useful for tracking down hotspots in the program.

Several libraries exist to mechanize the process of writing name capture and substitution, since it is largely mechanical. Probably the most robust is the library. For example we can implement the infer function for a small Hindley-Milner system over a simple typed lambda calculus without having to write the name capture and substitution mechanics ourselves.

Recently unbound was ported to use GHC.Generics instead of Template Haskell. The API is effectively the same, so for example a simple lambda calculus could be written as:

LLVM is a library for generating machine code. The llvm-general bindings provide a way to model, compile and execute LLVM bytecode from within the Haskell runtime.

Generates the following textual LLVM IR which can them be executed using the JIT in the package or passed to the various llvm commandline utilities.

The pretty printed form of the combinator:

The library can be used to pretty print nested data structures in a more human readable form for any type that implements . For example a dump of the structure for the AST of SK combinator with .

Adding the following to your ghci.conf can be useful for working with deeply nested structures interactively.

is a Wadler-style pretty printing library that uses Text builder objects for efficient generation under the hood. It exposes effectively the same interface as the String-based library but is much more performant.

Haskeline is cross-platform readline support which plays nice with GHCi as well.

Certain sets of tasks in building command line REPL interfaces are so common that is becomes useful to abstract them out into a library. While haskeline provides a sensible lower-level API for interfacing with GNU readline, it is somewhat tedious to implement tab completion logic and common command logic over and over. To that end Repline assists in building interactive shells that that resemble GHCi's default behavior.

Trying it out. ( indicates a user keypress )

Template Haskell is a very powerful set of abstractions, some might say too powerful. It effectively allows us to run arbitrary code at compile-time to generate other Haskell code. You can some absolutely crazy things, like going off and reading from the filesystem or doing network calls that informs how your code compiles leading to non-deterministic builds.

While in some extreme cases TH is useful, some discretion is required when using this in production setting. TemplateHaskell can cause your build times to grow without bound, force you to manually sort all definitions your modules, and generally produce unmaintainable code. If you find yourself falling back on metaprogramming ask yourself, what in my abstractions has failed me such that my only option is to write code that writes code.

Quasiquotation allows us to express "quoted" blocks of syntax that need not necessarily be be the syntax of the host language, but unlike just writing a giant string it is instead parsed into some AST datatype in the host language. Notably values from the host languages can be injected into the custom language via user-definable logic allowing information to flow between the two languages.

In practice quasiquotation can be used to implement custom domain specific languages or integrate with other general languages entirely via code-generation.

We've already seen how to write a Parsec parser, now let's write a quasiquoter for it.

One extremely important feature is the ability to preserve position information so that errors in the embedded language can be traced back to the line of the host syntax.

Of course since we can provide an arbitrary parser for the quoted expression, one might consider embedding the AST of another language entirely. For example C or CUDA C.

Evaluating this we get back an AST representation of the quoted C program which we can manipulate or print back out to textual C code using function.

In this example we just spliced in the anti-quoted Haskell string in the printf statement, but we can pass many other values to and from the quoted expressions including identifiers, numbers, and other quoted expressions which implement the type class.

For example now if we wanted programmatically generate the source for a CUDA kernel to run on a GPU we can switch over the CUDA C dialect to emit the C code.

Run the resulting output through to get the PTX associated with the outputted code.

Of course the most useful case of quasiquotation is the ability to procedurally generate Haskell code itself from inside of Haskell. The framework provides four entry points for the quotation to generate various types of Haskell declarations and expressions.

The logic evaluating, splicing, and introspecting compile-time values is embedded within the Q monad, which has a which can be used to evaluate its context. These functions of this monad is deeply embedded in the implementation of GHC.

Just as before, TemplateHaskell provides the ability to lift Haskell values into the their AST quantities within the quoted expression using the Lift type class.

In many cases Template Haskell can be used interactively to explore the AST form of various Haskell syntax.

Using Language.Haskell.TH we can piece together Haskell AST element by element but subject to our own custom logic to generate the code. This can be somewhat painful though as the source-language (called ) to Haskell is enormous, consisting of around 100 nodes in its AST many of which are dependent on the state of language pragmas.

As a debugging tool it is useful to be able to dump the reified information out for a given symbol interactively, to do so there is a simple little hack.

Splices are indicated by syntax for the expression level and at the toplevel simply by invocation of the template Haskell function. Running GHC with shows our code being spliced in at the specific location in the AST at compile-time.

At the point of the splice all variables and types used must be in scope, so it must appear after their declarations in the module. As a result we often have to mentally topologically sort our code when using TemplateHaskell such that declarations are defined in order.

Extending our quasiquotation from above now that we have TemplateHaskell machinery we can implement the same class of logic that it uses to pass Haskell values in and pull Haskell values out via pattern matching on templated expressions.

Just like at the value-level we can construct type-level constructions by piecing together their AST.

For example consider that type-level arithmetic is still somewhat incomplete in GHC 7.6, but there often cases where the span of typelevel numbers is not full set of integers but is instead some bounded set of numbers. We can instead define operations with a type-family instead of using an inductive definition ( which often requires manual proofs ) and simply enumerates the entire domain of arguments to the type-family and maps them to some result computed at compile-time.

For example the modulus operator would be non-trivial to implement at type-level but instead we can use the function to splice in type-family which simply enumerates all possible pairs of numbers up to a desired depth.

In practice GHC seems fine with enormous type-family declarations although compile-time may increase a bit as a result.

The singletons library also provides a way to automate this process by letting us write seemingly value-level declarations inside of a quasiquoter and then promoting the logic to the type-level. For example if we wanted to write a value-level and type-level map function for our HList this would normally involve quite a bit of boilerplate, now it can stated very concisely.

Probably the most common use of Template Haskell is the automatic generation of type-class instances. Consider if we wanted to write a simple Pretty printing class for a flat data structure that derived the ppr method in terms of the names of the constructors in the AST we could write a simple instance.

In a separate file invoke the pretty instance at the toplevel, and with if we want to view the spliced class instance.

Haskell no language support for multiline strings literals, although we can emulate this by using a quasiquoter. The resulting String literal is then converted using toString into whatever result type is desired.

In a separate module we can then enable Quasiquotes and embed the string.

Often times it is neccessary to embed the specific Git version hash of a build inside the exectuable. Using git-embed the compiler will effectivelly shell out to the command line to retrieve the version information of the CWD Git repostory and use Template Haskell to define embed this information at compile-time. This is often useful for embedding in information in the command line interface to your program or service.

Alas we come to the topic of category theory. Some might say all discussion of Haskell eventually leads here at one point or another.

Nevertheless the overall importance of category theory in the context of Haskell has been somewhat overstated and unfortunately mystified to some extent. The reality is that amount of category theory which is directly applicable to Haskell roughly amounts to a subset of the first chapter of any undergraduate text. And even then, no actual knowledge of category theory is required to use Haskell at all.

Grossly speaking category theory is not terribly important to Haskell programming, and although some libraries derive some inspiration from the subject; most do not. What is more important is a general understanding of equational reasoning and a familiarity with various algebraic relations.

Certain relations show up so frequently we typically refer to their properties by name ( often drawn from an equivalent abstract algebra concept ). Consider a binary operation and a unary operation .

And of course combinations of these properties over multiple functions gives rise to higher order systems of relations that occur over and over again throughout functional programming, and once we recognize them we can abstract over them. For instance a monoid is a combination of a unit and a single associative operation over a set of values.

The most basic structure is a category which is an algebraic structure of objects ( ) and morphisms ( ) with the structure that morphisms compose associatively and the existence of an identity morphism for each object.

With kind polymorphism enabled we can write down the general category parameterized by a type variable "c" for category, and the instance the category of Haskell types with functions between types as morphisms.

Categories are interesting since they exhibit various composition properties and ways in which various elements in the category can be composed and rewritten while preserving several invariants about the program.

Two objects of a category are said to be isomorphic if we can construct a morphism with 2-sided inverse that takes the structure of an object to another form and back to itself when inverted.

For example the types and are isomorphic.

One of the central ideas is the notion of duality, that reversing some internal structure yields a new structure with a "mirror" set of theorems. The dual of a category reverse the direction of the morphisms forming the category COp.

Functors are mappings between the objects and morphisms of categories that preserve identities and composition.

Natural transformations are mappings between functors that are invariant under interchange of morphism composition order.

Such that for a natural transformation we have:

The simplest example is between (f = List) and (g = Maybe) types.

Regardless of how we chase , we end up with the same result.

Or consider the Functor .

A lot of the expressive power of Haskell types comes from the interesting fact that, with a few caveats, polymorphic Haskell functions are natural transformations.

See: You Could Have Defined Natural Transformations

The Yoneda lemma is an elementary, but deep result in Category theory. The Yoneda lemma states that for any functor , the types and are isomorphic.

So that we have:

The most broad hand-wavy statement of the theorem is that an object in a category can be represented by the set of morphisms into it, and that the information about these morphisms alone sufficiently determines all properties of the object itself.

In terms of Haskell types, given a fixed type and a functor , if we have some a higher order polymorphic function that when given a function of type yields then the behavior is entirely determined by and the behavior of can written purely in terms of .

Kleisli composition (i.e. Kleisli Fish) is defined to be:

The monad laws stated in terms of the Kleisli category of a monad are stated much more symmetrically as one associativity law and two identity laws.

Stated simply that the monad laws above are just the category laws in the Kleisli category.

For example, is just an identity morphism in the Kleisli category of the monad.

Let us attempt to objectively compare Haskell to other programming languages with regards to which language principles they share and in what respects they differ. These comparisons are not advisements to use or avoid any of these languages, but rather statements of the similarities and differences between them at the language level.

No notion of "weak" or "strong" typing will be discussed because the terms have no universal meaning.

No notion of "object-oriented" or "functional" paradigms will be discussed because the terms have no universal meaning.

Haskell's genesis happened in 1987 at the Functional Programming Languages and Computer Architecture conference in Portland, OR. Participants had achieved a consensus that there was a profusion of non-strict, pure languages and concluded that this excess was hampering the development and wider use of such languages. Subsequently, a committee was formed to design a new pure, lazy, general purpose programming language. Out of this collaboration emerged Haskell, named for logician Haskell B. Curry, upon whose research the logical underpinnings of the Haskell language rest.

Since 1987, the Haskell language standard has continued to evolve. Haskell 1.0 was released in April of 1990, with particularly significant updates to the standard released in 1998 and 2010.

Haskell's main implementation is ghc. GHC is licenced under a permissive, non-copyleft, 3-clause BSD-style licence.

Haskell allows polymorphism by means of parametric polymorphism and ad-hoc polymorphism through typeclasses.

OCaml, originally known as Objective Caml, is the main implementation of the Caml programming language. The type system of OCaml is significantly less advanced than modern GHC Haskell and does not supported higher-kinded types or type-level programming to the extent that has become prevalent in portions of recent Haskell. The OCaml compiler is also significantly less advanced than modern GHC runtime and largely does not perform any compiler optimizations or program transformations. The language itself does have several advantages over Haskell in that is has a module system. Although it is possible to write pure OCaml, there is no language-integrated support, and the current engineering practice around the language encourages ubiquitous impurity in third-party libraries.

Main difference: Both have fairly modern type systems, but OCaml does not enforce purity and uses call-by-value.

OCaml's main implementation is ocamlc. The OCaml compiler is distributed under the Q Public licence, a permissive, non-copyleft FLOSS licence. Some portions of the OCaml libaries are licensed under the GPLv2. See the OCaml GitHub page for more information about licensing specifics.

OCaml allows polymorphism by means of parametric polymorphism and ad-hoc polymorphism through modular implicits.

OCaml is not an optimizing compiler.

OCaml is impure by default and does not statically track effects.

Standard ML was a general-purpose, modular, functional programming language with compile-time type checking and type inference.

Standard ML was traditionally a general purpose language, although it's lack of a modern compiler largely only makes it useful for work on pure type theory and proof assistants and not in industrial settings. Standard ML has been largely abandoned in recent years and is a good example of a promising language that withered on the vine from a lack of engineering effort devoted toward the backend compiler.

Main difference: Standard ML is no longer actively developed, Haskell is.

Standard ML's main implementation is smlnj. Other implementations existed in mlton and polyml.

Standard ML allows polymorphism by means of parametric polymorphism.

Standard ML is impure by default and does not statically track effects.

Agda is a dependently typed functional programming language used in type theory research. Unlike Coq, has no support for tactics, and proofs are written in a functional programming style.

Main difference: Agda is not a general purpose language, Haskell is. Agda is not used to write executable programs for practical uses outside of research.

Agda is not a general purpose language, it is largely used as a proof environment and tool for constructive mathematics.

Coq is an interactive theorem prover based on the calculus of inductive constructions. It compiles into a Core language called Gallina whose defining feature is that it is weakly normalizing (i.e. all programs terminate ). Although Coq allows limited extraction of some programs to other languages, it is not by itself a programming language in the traditional sense, most Coq programs are not run or compiled.

Main difference: Coq is not a general purpose language, Haskell is.

Coq is not a general purpose language, it is largely used as a proof environment.

Main difference: Idris has dependent types and call-by-value semantics, Haskell does not have dependent types and uses call-by-need.

Idris allows polymorphism by means of parametric polymorphism and ad-hoc polymorphism.

Idris is garbage collected by default, although there is some novel work on uniqueness types which can statically guarantee aliasing properties of references.

Rust is a general-purpose, multi-paradigm, compiled programming language developed by Mozilla Research. It incorporates many of the foundational ideas of Haskell's type system but uses a more traditional imperative evaluation model. Rust includes type inference, ad-hoc polymorphism, sum types, and option chaining as safe exception handling. Notably Rust lacks higher-kinded types which does not allow many modern functional abstractions to be encoded in the language. Rust does not enforce purity or track effects, but has a system for statically analyzing lifetimes of references informing the efficient compilation of many language constructs to occur without heap allocation.

Main difference: Rust is a modern imperative typed language, Haskell is a modern functional typed language with recent type system. Rust does not have the capacity to distinguish between pure and impure functions at the language level.

Rust allows polymorphism by means of parametric polymorphism and ad-hoc polymorphism.

Rust is not garbage collected by default, instead uses static semantics to analyze lifetimes. Optionally supports garbage collection.

Rust is impure by default and does not statically track effects. It does however have static tracking of memory allocations and lifetimes.

Purescript is a Haskell-like language that compiles into Javascript for evaluation within a web browser. Semantically it is very close to Haskell except that is uses a call-by-value model instead of Haksell's call-by-need. The type system is a superset of Haskell 2010 and includes ad-hoc polymorphism, parametric polymorphism, rank-n polymorphism, row-polymorphism, higher-kinded types and full algebraic data types.

Main difference: Purescript targets Javascript in the browser, while GHC Haskell is designed to work on top of the GHC managed runtime.

Purescript is pure and statically tracks effects using an extensible record system embedded in the Eff monad.

Elm is a ML-like language that compiles into Javascript for evaluation within a web browser.

Main difference: Elm targets Javascript in the browser, while GHC Haskell is designed to work on top of the GHC managed runtime. Elm lacks any semblance of a modern ML type system features, and has no coherent story for overloading, modules or higher polymorphism.

Elm targets Javascript and is "transpiled" to Javascript source code to be run exclusively in a browser or Javascript interpreter.

Elm allows polymorphism by means of parametric polymorphism.

Python is a widely used general-purpose, high-level programming language. It is based on object-style of programming constructions and allows first class functions and higher order functions. Python is unityped and is notable for it's simplistic runtime and global mutex preventing concurrency.

Main difference: Python is unityped and imperative, Haskell is statically typed.

Python is impure by default and does not statically track effects.

Python internally refers to runtime value tags as types, which differs from the Haskell notion of types.

Python allows polymorphism by means of unityping, all functions can take any type.

R is a programming language and software environment for statistical computing and graphics. The R language is widely used among statisticians and data miners for developing statistical software and data analysis

Main difference: R is unityped and domain specific language, Haskell is statically typed and general purpose.

R allows polymorphism by means of unityping.

R internally refers to runtime value tags as types, which differs from the Haskell notion of types.

Julia is a high-level dynamic programming language designed to address the requirements of high-performance numerical and scientific computing.

Main difference: Julia is unityped and imperative, Haskell is statically typed.

Julia allows polymorphism by means of unityping.

Julia internally refers to runtime value tags as types, which differs from the Haskell notion of types.

Julia is compiled through the LLVM framework.

Erlang is a general-purpose programming language and runtime environment. Erlang has built-in support for concurrency, distribution and fault tolerance.

Main difference: Erlang is unityped and imperative, Haskell is statically typed and functional.

Erlang allows polymorphism by means of unityping.

Erlang internally refers to runtime value tags as types, which differs from the Haskell notion of types.

Erlang is impure by default and does not statically track effects.

Java is a general purpose programming language. It is an object-oriented, concurrent language which is statically typed. It is one of the most frequently used languages in the industry, as well as a common language used in academia to teach the fundamentals of object oriented programming.

Main difference: Java is an object-oriented language, compared to Haskell which is functional.

Java is statically compiled to Java Bytecode which can be ran on a Java Virtual Machine.

Java is cross-platform. It can be ran on Linux, Windows and Mac.

Clojure is a modern LISP dialect that emphasizes immutability. It does not enforce safety and idiomatic clojure often includes mutable references and destructive updates. There are some efforts toward an optional typing system provided by the core.typed.

Main difference: Clojure is a unityped typed Lisp dialect, while Haskell is in the ML family.

Clojure allows polymorphism by means of unityping.

Clojure internally refers to runtime value tags as types, which differs from the Haskell notion of types.

Swift is a multi-paradigm language created for iOS and OS X development by Apple. Swift incorporates recent developments in language design and uncommonly includes return type polymorphism, type inference, ad-hoc polymorphism, sum types, and option chaining as safe exception handling. Swift does not enforce purity or track effects, and allows mutable and destructive updates.

Main difference: Swift is reasonably modern imperative typed language, Haskell is a modern functional typed language.

Swift allows polymorphism by means of parametric polymorphism and ad-hoc polymorphism through through inheritance, interfaces, and reflection.

Swift is compiled through the LLVM framework.

Swift does not have an effect system.

C# is a typed, class-based, single-inheritance object-oriented programming language originally developed at Microsoft as the flagship language for the .NET framework. Early versions closely resemble Java, but the language has since picked up a few influences from declarative and functional programming paradigms. .NET is Windows-only, but a cross-platform replacement, Mono, exists, that makes it possible to run .NET code on OS X and Linux.

Main difference: C# is an impure object-oriented language, Haskell is a pure functional language.

C# is garbage collected (but allows opting out of GC through the use of blocks)

C# is a statically typed language with limited type inference and some support for dynamic typing.

C# allows polymorphism by means of parametric polymorphism through generics, ad-hoc polymorphism through inheritance, interfaces, and reflection.

C# is impure and does not track effects.

C# is typically compiled to .NET IL, which is then interpreted by the .NET runtime.

C++ is a typed multi-paradigm (imperative, structured/procedural, class-based multiple-inheritance object-oriented, template metaprogramming) programming language developed by Bjarne Stroustrup in the early 1980s. The philosophy strongly favors zero-cost abstractions, and values performance higher than convenience. This has made the language extremely large and complex, and the culture and ecosystem diverse and fractured. Today, C++ is mainly found in legacy projects, but remains popular in areas where realtime performance and deterministic memory allocation are critical, such as embedded, audio/video, games, HFT, etc.

Main difference: C++ is impure and uses RAII, Haskell is pure and garbage-collected.

C++ has no canonical implementation; notable compilers include gcc, clang, and MSVC++.

C++ is a general purpose programming language, with a bias towards systems programming.

C++ is not garbage collected. Manual memory management (as in C) is supported, but the recommended paradigm is RAII.

C++ is a statically typed language with limited type inference and many backdoors to bypass the type checker.

C++ allows polymorphism by means of parametric polymorphism through template metaprogramming, and ad-hoc polymorphism through inheritance.

C++ is compiled, the typical compilation target is native machine code.

C++ does not track effects. It has limited support for tracking mutability at the type level.

Go is a programming language developed at Google. Although Go is statically typed, it has failed to integrate most modern advances in programming language design done after the 1970s and instead chooses a seemingly regressive design. Most notably, it lacks any notion of generics, while polymorphism is achieved either by manual code duplication or unsafe coercions.

Main difference: Go is a language designed around the idea that language design has not advanced since 1970, while Haskell incorporates many ideas from modern research.

Go has no safe polymorphism.

Go is statically compiled with a custom toolchain.

Go does not have an effect system.

Scala is a general purpose multi-paradigm language. Like Java, Scala is object-oriented, and uses a curly-brace syntax reminiscent of the C programming language. Unlike Java, Scala has many features of functional programming languages like Scheme, Standard ML and Haskell, including currying, type inference, immutability, lazy evaluation, and pattern matching.

Main difference: Scala mixes functional programming with imperative programming and does not take a language-integrated stance on purity or effect tracking which breaks equational reasoning. External libraries and frameworks exist that embrace functional programming more effectively, but it is not enforced and imperative code and thin wrappers around Java libs quite often leaks industrial codebases.

Scala allows polymorphism by means of parametric polymorphism and ad-hoc polymorphism through implicits.

Scala language does not have an effect system.

JavaScript is a high-level, dynamic, untyped, and interpreted programming language that was ubiquitous in web development during the 90s and 00s. Javascript is most kindly described as a language that "just happened" and an enduring testament to human capacity to route around problems.

Main difference: Like many web technologies Javascript "just happened" and it's design was dominated by economic factors. Haskell was designed with some insight into the end result.

Javascript allows polymorphism by means of unityping.

Javascript internally refers to runtime value tags as types, which differs from the Haskell notion of types.

The majority of Javascript implementations are garbage collected.|||

