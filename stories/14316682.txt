Weâ€™ve already learned about the history of Unicode and how it works under the hood. In this final part, weâ€™ll learn the theory and practice of handling Unicode properly.

Before we get into practice Iâ€™d like to talk a bit about Unicode support in Ruby language. If youâ€™re not a Ruby developer, fell free to scroll past the first chapter.

This header suggests, that Ruby and Unicode donâ€™t go well together. And it might seem surprising because after all Ruby allows you to write some declarations like this one.

Which then can be used for method calls.

And it gives an expected output.

Looks like pretty good Unicode support, doesnâ€™t it? After all, weâ€™re writing code with emojis, which are very Unicodeâ€™y. But there is something more about supporting Unicode than being able to just write it.

As usual, letâ€™s start with history. How about going back to the times when Ruby was not even in version 1.9? Have any of you ever used Ruby pre-1.9? Honestly, I havenâ€™t, but from what the elders of the Internet have told me, Strings didnâ€™t have any special powers there. They were just simple arrays of bytes. And an array of bytes doesnâ€™t care about character encoding at all. You give it some data and it will hold this data for you, but ask it to do something with itâ€¦ and things can get strange.

Letâ€™s start with Ruby 1.8.7 (the latest one before 1.9) and check how Strings work there.

Nothing surprising here. Weâ€™ve created a String without any problems. But what if youâ€™re a developer from Poland, and you wanted to use Polish variable names (please donâ€™t ever do this) and Polish strings? Letâ€™s call our variable â€œtreÅ›Ä‡â€ (which means content) and assign local version of Hello World to it.

We can see that Ruby didnâ€™t even manage to read the name of our variable. Actually, it didnâ€™t even manage to properly recover from this Error and just shut down the irb. Itâ€™s a pretty obvious sign that we shouldnâ€™t expect much Unicode support here.

But just to be sure, letâ€™s remove special characters from variable name and try again.

We can see that instead of the letter â€œÅšâ€ (U+015A) we got â€œ\305\232â€. Those numbers are octal form of UTF-8 representation of this letter (â€œU+015A in UTF-8 is C59A). No support for Unicode this time.

Well, actually there was a way to ask Ruby to use UTF-8 as the default encoding. Will it work for us?

Woah, it looks like everything is working now. Can you guess how long is this obviously-4-letters-long-text?

Obviouslyâ€¦ 4 letters long text is 7 letters long. How about trying to make it all uppercase?

That Ruby version should be actually considered a prehistory. What followed next, brought quite a few good changes. Everybody welcome Ruby 1.9.

We saw itâ€™s release on 25th Dec 2007â€Šâ€”â€Šexactly 11 years after Ruby 1.0. One of the biggest changes was the improved String class. From now on, it would support many different encodings and support UTF-8 as a default one. Are you as excited as I am to check it out?

Letâ€™s fire up irb for Ruby 1.9.3 and check if its default encoding really is UTF-8.

My Ruby build was somehow broken and decided not to show version number in prompt. But it seems that it indeed supports UTF-8 and we can use it out of the box.

Letâ€™s do the turtle test once more. Can you guess how long will the turtle be this time?

Wooohoo ğŸ‘ğŸ‰ğŸ¾ Our turtle is 4 characters long. But wait. There was a second test. Can we make the turtle bigger?

Ruby 1.9 is actually also a prehistory. After all, weâ€™re using ruby 2.x right now. Itâ€™s not 1, itâ€™s 2. The whole new version of a language. Letâ€™s just open the prompt for Ruby 2.3.3, which I happened to have set as a default one.

Actually, Iâ€™m not sure what Iâ€™ve expected.

As you may know, Ruby 2.3 is not the latest one. Not so long ago, on 25th Dec 2016, Ruby 2.4 had its release. Exactly 20 years after the first release, there was one important change:

Is this what weâ€™ve all been waiting for? Can we finally make our turtle bigger?

We can all happily go home now. Our work is done for today. But in the very last moment, a new wild turtle appears.

It looks just like the previous one, but we have the feeling that something is not quite right with it. But just to be sure, letâ€™s check itâ€™s length. Can you guess how long can it be?

What happened here? If it was 7 characters long it would have been obvious. But itâ€™s not. Letâ€™s inspect whatâ€™s inside of it (sounds quite brutal when talking about turtles ğŸ˜¨).

For some reason, our â€œÅ¼â€ and â€œÃ³â€ got separated into two characters. If you remember things Iâ€™ve talked about previously, you may recognise Combining Diacritical Marks here. But just to make things clear. In Unicode, there are two ways to write regional characters. The first one is to use precomposed letter, which is represented as one character. The other method is to use the â€œbaseâ€ letter and follow it with a special combining character (such as dot, wave, slash etc.) which is displayed together with the preceding letter. But as we can see displaying is not the same as keeping in memory.

We can now verify whether or not Ruby handles such combined characters properly. Can we find a precomposed â€œÅ¼â€ inside our â€œÅ¼Ã³Å‚wâ€?

To be honest there was no reason at all for this to work.

Weâ€™re almost ready to talk about ways of fixing this. There is only one more thing left for us to check. What if we tried to reverse our turtle? Or rather have it reversed and try to make it â€œrightâ€ again?

Look at how our â€œÃ³â€ lost itâ€™s upper thing (there is definitely some smart name for it) and became a plain boring â€œoâ€. And our â€œÅ¼â€ became a â€œÅºâ€. Not to mention the opening quotation mark of our string having a dot above. A dot above a quotation markâ€¦ ğŸ™ƒ

The reason for this is that deep inside, Strings are still like arrays. If you reverse it, you get what you ask for.

Itâ€™s high time we try to solve all those issues.

At this point, everyone skipping the Ruby part should join us. Hello ğŸ‘‹ And Iâ€™ve lied to you because the first solution Iâ€™ll show is Ruby only.

If youâ€™re working with Ruby on Rails, youâ€™d already have ActiveSupport installed. It extends String with mb_chars method. What this method does is wrap the string in â€œActiveSupport::Multibyte::Charsâ€ class. This class makes all String methods such as â€œreverseâ€, â€œupcaseâ€ etc. work as expected.

And indeed it does work. And just to make sure weâ€™ve been reversing a string with composing characters letâ€™s see all the characters.

As we can see, mb_chars made our string behave less like an array and more like an actual text.

But some of us would probably want to avoid using Ruby on Rails (or loading huge gems) just to work with text.

And thatâ€™s when we should talk about built-in ways of handling this.

Normalization is a way of turning many forms of data into a unified one. In the case of text strings, it means encoding them into one before-agreed form, called a normal form. The Ruby way of normalizing strings is â€œunicode_normalizeâ€ method. Other languages should have something similar (provided that they donâ€™t do this by default).

To see it in action, first create two different turtles: one with precomposed letters, other using composable characters.

We can see that those two strings are indeed different. But when we normalize them before comparingâ€¦

To see whatâ€™s going on here, take a look at the string before and after normalization.

It looks like â€œunicode_normalizeâ€ changes all Unicode-magical characters into normal ones.

Sounds cool, right? Letâ€™s do this in our production environment. Weâ€™re now ready for everything Unicode has for us. For example, someone sends us some text which looks like â€œa a a aâ€¦â€ but has all sorts of funky a-like characters.

But weâ€™ve got nothing to worry about. Weâ€™re normalizing our strings, so it should all get changed into some normal â€œaâ€.

But it was not.

The reason for this is, that there are many different normal forms you can use. Unicode Standard describes 4 ways to normalize a string. To see all of them letâ€™s use a string which has all kinds of funky Unicode stuff inside.

We have a â€œÂ¼â€ character which everybody knows has 3 different characters inside: â€œ1â€, â€œ/â€, and â€œ4â€. Then is a space, or rather a nonbreaking space which looks like a space but cannot be broken across lines. â€œwâ€ is quite normal here, but then you have a Polish precomposed letter â€œÄ™â€ and â€œzâ€ with a composable dot above. The â€œaâ€ is once again just a boring letter.

The first (default) normal form is called NFC. NF stands for Normal Form, while C means Compose. You can probably guess how it works.

All it does is taking letters with composable characters and turning it into one, precomposed letter. It composes â€œzâ€ and a dot into â€œÅ¼â€.

The second normal form is NFD, with D meaning Decompose. This is opposite to what we just saw above and is usually used only for some specialised internal processing.

As expected, it turned the precomposed â€œÄ™â€ into â€œeâ€ and a composable hook which is called â€œogonekâ€.

The next form is the most common when turning strings into identifiers (such as database keys). Itâ€™s called NFKC, with K standing for Compatibility.

Apart from doing the compose part, it additionally takes care of all those special characters such as â€œÂ¼â€ and the nonbreaking space. It changes them into their compatible counterparts, which are â€œ1â€, â€œ/â€, â€œ4â€ and a standard space.

As you might have guessed, the last form is NFKD.

Itâ€™s like the previous one, but decomposes characters instead of composing them.

Equipped with all this knowledge we can now try another take on normalizing our â€œa a a aâ€¦â€. It looks like the default NFC form is missing the Compatibility part, which we need here. Letâ€™s check if NFKC gives us better results.

It gives us an expected string of standard letters â€œaâ€. But at this point, we probably have some trust issues as far as Unicode is concerned. Weâ€™d better make sure all those â€œaâ€ are the same. Can we turn them into turtles?

Normalization is a great way to handle Unicode strings and turn them into more usable form. It solves many problems, but can also create new ones if used without special care.

One example of how Unicode can create security threats in your application happened to Spotify in 2013. There was a way to takeover any user account using Unicode-related stuff.

Spotify has supported Unicode in usernames for a long time (seriously, itâ€™s possible to name your account something like â€œÂ¼ğŸğŸ¢â€). To handle this correctly they use two forms of your username. One is a verbatim form and is used purely for display purposes. The second one, called a canonical form, is used for all sorts of processing (comparing, checking the database etc). To turn a verbatim form into canonical one, it has to undergo a process called canonicalisation. And thatâ€™s where the problem came from.

For the sake of this article weâ€™ll simplify what happened to Spotify but will keep the main idea and an attack vector unchanged. Letâ€™s see how easy it is to create a serious security issue.

Imagine you have an app, where usernames arenâ€™t case sensitive. Your users are happy as they donâ€™t have to remember whether they used capital letters or not. They can login as â€œGreatUserâ€, â€œgreatuserâ€, â€œgreatuSERâ€ etc. and still get access to their account. To achieve this, youâ€™ve created a very simple canonicalising method, which makes username all uppercase.

Now when you log in using â€œAdminâ€ username to access all the secret admin stuff in your app, the username will be turned into uppercase â€œADMINâ€. It all works as expected.

But since weâ€™re all modern and keeping up with latest trends, we allow users to use Unicode characters when logging in. Itâ€™s all working great until some evil hacker appears with the intention to mislead users on your message board (yes, weâ€™re making a message board type application ğŸ˜). What they do is register as an â€œğ– dminâ€ with some hacky magical Unicode â€œğ– â€.

And they can do this because this â€œğ– â€ is not the same as â€œAâ€.

We cannot allow for such thing! Luckily, we remember how weâ€™ve learned about Unicode normalization some time ago, and decide that itâ€™s the way to go. We may even remember that the best normal form for things like identifiers is NFKC. So we proceed and fix out canonicalisation method.

Hooray! Problem solved. Now, none of those evil hackers can login as â€œğ– dminâ€ anymore.

But there is one problem with our canonicalisation method. In real life, things such as canonicalisation may be performed a lot of times on the same text. You can do this as many times as you like thanks to method idempotence (watch out, a wild hard word appeared). The idempotent method has a nice feature, that when you call it many times it gives the same result as when you call it only once. For example â€œupcaseâ€ is idempotent. You canâ€™t make a text more uppercase even when you try it a million times.

On the first sight, we might think that our canonicalisation method is idempotent as well. After all, when we try â€œto_canâ€ on those evil â€œğ– dminâ€ thing, we get exactly the same result.

But keep in mind that hackers are clever. And they come up with a new attack variation. Now, they try to use â€œáµƒdminâ€ as a login. And to our dismay, itâ€™s not the same after two method calls as it is after one.

Does it mean that our canonicalisation method is not idempotent? Letâ€™s check whatâ€™s happening here step by step.

Now it should get obvious. Even though we may expect it to do so, calling â€œupcaseâ€ on this little â€œáµƒâ€ doesnâ€™t turn it into â€œá´¬â€. So after uppercasing the username, weâ€™re left with â€œáµƒDMINâ€ which gets normalised into â€œaDMINâ€, which is not taken yet. The hacker can sign up with such username and it will be stored in the database as â€œaDMINâ€.

Then, they request a password reset for this account. We extract this user from the database, allow the user to set a new password and save the new password to the database. And if at this very moment, just before saving, we canonicalise the username again (not our fault, we thought our method is idempotent). Weâ€™ve just changed a password for â€œADMINâ€ user ğŸ˜±

And itâ€™s more or less what happened to Spotify.

Do you have an idea for fixing it? Itâ€™s actually really easy. Our problem is in â€œupcaseâ€ not handling all Unicode characters as expected. To get rid of this we should normalise the string before making it uppercase.

And that would be all for this wild 3-part Unicode adventure. Thanks for staying with me and I hope youâ€™ve learned something useful here. Feel free to ask any questions, and Iâ€™ll try to do my best to help you out ğŸ¤“

If you enjoyed this post, please donâ€™t forget to tap â¤! You can also follow us on Facebook, Twitter and LinkedIn.|||

We already know how Unicode works under the hood. In this final part, weâ€™ll learn the theory and practice of handling Unicode properly.