The Liar Paradox is simple enough to explain â€“ is the following statement true or false?

If itâ€™s true then itâ€™s false, but if itâ€™s false then itâ€™s true Â â€¦ nothing works.

In my not-so-humble opinion, most (maybe all) paradoxes are the last step in a proof by contradiction that some unstated assumption is false.

In this case, the assumption is that the above statement is meaningful â€“ is either true or false. The assumption is false, the statement is meaningless. End of paradox.

Of course, thereâ€™s more to it than that. Behind the Liar Paradox is a more general, and seemingly sensible assumption, that any statement that is syntactically correct is meaningful. Obviously, not the case. Hereâ€™s another example

I do not believe this statement.

If I believe it, then I donâ€™t, and if I donâ€™t, then I do.

Itâ€™s tempting to believe that self reference is the problem, but there are plenty of self referential sentences that are (or seem â€¦ ) meaningful and true; e.g. â€œI know this sentence is trueâ€.

To get to the bottom of this we need to formalize the paradox. This was first done by the famous logician Alfred Tarski (in 1936). In his formalization, the problem is the phrase â€œis trueâ€.

More than 80 years later you can explain it without getting too technical. Imagine we have a formal logical language with quantifiers, variables, Boolean connectives, arithmetic operations and (this really helps) strings and string operations. Call this language â„’. At this stage everything syntactically correct makes sense. For example, we can state that string concatenation is associative, or that multiplication distributes over addition.

Since we have strings, we can talk about expressions and formulas in the language itself. We can define a predicate (of strings) that is true iff the string is a syntactically correct formula. We can define an operation â€œsubsâ€ that yields the result of substituting Â an expression for a variable; more precisely, subs(f,g) is the result of substituting g for every occurrence of x in f. So far, no problem. Can we produce a formula that refers to itself? Not yet.

GÃ¶del numbers? No need. The whole point of GÃ¶del numbering is to show that you donâ€™t need strings, you can represent them as (arbitrarily large) integers. This is important but not particularly interesting. In modern computer science terms, it means implementing strings as (arbitrarily long) integers, and nowadays (but not in the 30â€™s) everyone believes this without seeing the details.

So far so good. One last little step â€¦ and we go over the cliff. The last step is to add a predicate T of Â strings that says itâ€™s argument is a formula and that this formula is true (with free variables universally quantified). T seems harmless enough, but with it we can reproduce the Liar Paradox.

Provided we can make a sentence refer to itself. This, not GÃ¶del numbering, is the tricky part.

SinceÂ â„’+ has strings, subs, and T, we can talk about whether or not a formula is true of itself (as Â a string). If a formula is not true of itself (it â€˜rejectsâ€™ itself) letâ€™s call it neurotic.

To see that we can define neurosis, letâ€™s say that a formulaÂ Î¦ is true of a formulaÂ Î˜ iffÂ Î¦ is true when all occurrences of the variable x inÂ Î¦ are replaced byÂ Î˜ (as a string constant). If we call the result of this substitution Î¦[Î˜], then to say that Î¦ is true of Î˜ is to say that Î¦[Î˜] is true.

Then letÂ Î¨ be the sentence

It should be clear thatÂ Î¨Â says that its argument is neurotic. What about Î¨, is it neurotic?Â Â Is Î¨[Î¨]Â true or false?

On the one hand, if itâ€™s false, then by definition of neurosisÂ Î¨ is neurotic. But since Î¨ tests for neurosis, Î¨[Î¨]Â should be true. On the other hand, if Î¨[Î¨]Â is true, then sinceÂ Î¨ tests for neurosis,Â Î¨ is neurotic. But this means by the definition of neurosis,Â Î¨ is not neurotic. No way out. (You may recognize this as a variant of the â€œbarber who shaves all those who donâ€™t shave themselvesâ€ paradox.)

Thus Î¨[Î¨]Â is our liar sentence. I can tell you exactly what it is; itâ€™s

and is, by my count, 41 characters long.

We can make the argument clearer (if not as precise) using our functional shorthand. We defineÂ Î¨ by the rule

Those who are familiar with theÂ Î» calculus or combinatory logic will detect the Y combinator behind this argument. The combinator Y is, as aÂ Î»-expression,

Itâ€™s called a fixed point combinator because YF reduces to F(YF); YF is a fixed point of F. The ISWIM (where -clause) version is much easier to understand:

Working back from this contradiction, it means we canâ€™t consistently add a truth predicate to our basic language â„’. That in turn means that we canâ€™t define T in â„’, otherwise the â„’ would be inconsistent. Thatâ€™s what Tarski meant when he called his result â€œthe undefinability of truthâ€.

Can we salvage anything from this? Yes, and this is due to Tarski and Saul Kripke.

There is no harm in applying T to formulas that donâ€™t use T, the meaning is obvious. Call the language allowing thisÂ â„’ â€˜. Similarly, applying T toÂ â„’ â€˜ formulas is ok, call the language where this is allowed as wellÂ â„’ â€. We can create a sequenceÂ â„’,Â â„’ â€˜,Â â„’ â€,Â â„’ â€â€™, â€¦ (This is Tarskiâ€™s hierarchy).

We can throw these all together producing a languageÂ â„’ *. But then we can createÂ â„’*â€™,Â â„’*â€ etc. Generalizing this we have a hierarchy indexed by the countable ordinals (donâ€™t ask). Kripkeâ€™s proposal was to define a single language with a single truth predicate in which anything goes but in which sentences not caught up in this construction have an intermediate truth value. Thus Î¨[Î¨]Â would be neither -1Â (false) nor +1 (true) but 0, with 0 being its own negation. Iâ€™ll let you decide whether this makes Î¨[Î¨]Â meaningful after all.

Sentences that have a conventional truth value Kripke calls grounded; those, Â like the liar sentence, ungrounded. You can think of the ungrounded sentences as those in which evaluation fails to terminate. Notice that â€œthis statement is trueâ€ is ungrounded. (Kripke found a way around this but I wonâ€™t go into the details.)

Finally, infinitesimal logic can shed some light on groundedness. If we redefine T(f) to be the truth value of f times ğ›†, and evaluate over the infinitesimal truth domain

then we get a more nuanced result. The power of the infinitesimal tells us roughly how many layers of truth predicate we have to go throughÂ to decide between true and false.|||

The Liar Paradox is simple enough to explain - is the following statement true or false? This statement is false. If it's true then it's false, but if it's false then it's true Â ... nothing works. In my not-so-humble opinion, most (maybe all) paradoxes are the last step in a proof by contradiction that someâ€¦