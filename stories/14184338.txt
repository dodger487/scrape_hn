Hello folks! Iâ€™m here again this time toÂ talk about static analysis. If you are a developer with little to noÂ knowledge on the subjectÂ this is the right article for you. Static analysis is the process of analyzing the code of a program without actually running it as opposed to dynamic analysis where code is analysed at run time. This processÂ helps the developerÂ toÂ identify potential design issues, bugs, to improve performances and to ensure conformance to coding guidelines.Running static analysis regularly is a good practice and if itâ€™s done regularly it helps identifying issues at an early phase of the software development life cycle. It is mainly used on strongly-typed, static languages like C/C++, C# or JavaÂ and there are plenty of productsÂ out there, either free and commercial. Have a look at thisÂ wikipediaÂ article.

The aim ofÂ this article is to test the effectiveness of static analysis on a very famous game physics engine.Â BulletÂ Physics and eventually create a pull request if any fixes arise.Â BulletÂ Physics is an open source SDK for real-time collision detection and it has beenÂ used in 3D authoring tools like Blender, games like Grand Theft Auto VI, Grand Theft Auto VÂ and Rocket LeagueÂ andÂ also movies. You can find out more in this Wikipedia article. For this taskÂ I usedÂ a commercial tool called PVS-StudioÂ fromÂ viva64 for which IÂ received a free temporary license. PVS-Studio is a static analyzer for C++Â and C#. A demo versionÂ can be downloaded for free. The demo has limitations on the available â€œclicksâ€ the user can perform on theÂ warnings it generates.

Static and dynamic analysis are two faces of the same coin, while the formerÂ is performed on the codeÂ at â€˜compile timeâ€™, the latter is insteadÂ done at run-time usually using a given input data. An example of dynamic analysis is code coverage, which measures to what degree code is covered by tests. Running unit or integration tests are also examples of dynamic analysis. Dynamic analysis is a very widespread practice. Test-driven developmentÂ for example, has dynamic analysis at his core. Nowadays it is odd to think aboutÂ an open source or a commercial projectÂ where code is not covered by tests, isnâ€™t it? We all know the benefits of having good test coverage. HoweverÂ static analysis takes a different approach but unfortunately it is not as widespread as dynamic analysis.

Static analysis can beÂ very effective because it can unearth bugs and errors earlier in the software development life cycle which would not emerge in a dynamic test. On the other side, static analysis is not a panacea to identify allÂ the issues and it has its cons. One of them is the accuracy that may lead to false positives. A false positive is a â€˜mistakeâ€™Â in reporting that a rule was violated. Moreover the process of going through hundred of warnings, especially in large projects of big teams where changes happen on a daily basis can be frustrating and time-consuming for developers. However theÂ effectiveness of static analysis grows proportionally with the project size because the error density in small projects is lower than in larger ones. You can find a nice explanation here.

I love game physics, in the past I used BulletÂ Physics in a lot of my projects (especially college projects ğŸ˜› ) and Iâ€™m really curious to see and to know what I can find out with static analysis. At the time of writing this article Iâ€™m using Bullet 2.86 commit hashÂ 5b789ed.

At first I used the tool available in Visual Studio. If you want to learn the basics of code analysis using theÂ Microsoft tools, you can find a lot of material on Microsoftâ€™s documentation on code analysisÂ page.

My first run of the Microsoftâ€™s static analyzer generated more than 800 warnings so I decided to create a smaller solution using only the main core libraries. In CMAKE when you generate the solution you need to un-check the following options under the BUILD category:

This time the generated warnings were 118. Letâ€™sÂ have a look at a typical output, so that you have an idea of what kind of hint a static analyzer gives you. Letâ€™s pick the btConvexHull.cpp file in the LinearMath project.

The warning above is composed of a code, which can be clicked and brings you to a page with a thorough explanation and an example of the warning itself, a description of the issue and whereabouts it happens. In the image below there is the code highlighted on the left and a side window on the right containing a full explanation of the issue. In the extrudable function the pointer btHullTriangle t*Â is set initially to NULL, in the case of the loop being skipped because of the array m_tris is empty then the pointer t* will never be set, and thus atÂ line 476 the pointer t* is dereferenced while still being null.

As you see the job of a static analyzer is to predict the execution flow and evaluate branches. Then it provides an explanation ofÂ warning and what specifically causes it. You may get the grasp now of how static analysis is different from dynamic analysis. In this case a bug can only be spotted if and only if the collection m_trisÂ is empty, which is a specific case that depends on data. However that might never happen either. For example the class btConvexHull calculates the convex hull of a given input polygon and m_tris represents the triangles of a generated simplex. The convex hullÂ of a setÂ of points (i.e. vertices) of a polygonÂ in aÂ Euclidean spaceÂ is the smallestÂ convex setÂ that containsÂ the polygon.Â Thus itâ€™s highly improbable thatÂ m_trisÂ will beÂ empty when the function extrudableÂ is called unless an empty set of vertices is passed. In general in the case where all call sites of the function (or of the class) guarantee that it isÂ only passed valid data then the warning can be ignored.Â If it canâ€™t be guaranteed that then the warning should not be ignored. Letâ€™s see what the PVS-StudioÂ produces on this file:

I have to admit that theÂ UI is much nicer and efficient as it groups the warnings by priority. There are two more sections for optimizations and 64-bit errors which lack in VS. The warning template is similar to VS, each warning is provided with aÂ code and a link that redirects toÂ page with a detailed documentation on the error,Â aÂ message and the line number. The careful reader might have already noted that there is no similar warning to the oneÂ discussed earlier (btConvexHull.cpp line 476) present in the list above. This is interesting but Iâ€™ll get back to it later. The high and medium priority warnings tell us that we should initialize some members in the btConvexHull class (error V730). Those members are all primitive types and in fact uninitialized members in C++ can lead to errors or undefined behaviors at runtime. It is to be saidÂ though that these warnings refer to parameterless constructors which are not used anywhere. An immediate solution would be removing these empty constructors. However it is to beÂ kept in mind thatÂ this is a library and itâ€™s hard to predict how it will be used, so itâ€™s almost mandatory to avoid any possible misuse that can generate bugs.

Low priority warnings suggest to avoid precise comparing of floating point numbers directly (error V550) and sayÂ instead to compare the absolute value of the difference with an epsilon value (e.g. 0.00001).Â Floating point math is not exact. Simple valuesÂ like 1.6 or 0.2 cannot be precisely represented using binary floating point numbers. Comparing two floats to see if they are equal is usually not a good idea. Compilers have warnings for this also (like GCC for example): â€œwarning: comparing floating point with == or != is unsafeâ€œ.

RunningÂ PVS-Studio on the whole solution of the core libraries returned a longer list of warnings, look at the picture below:

Itâ€™s not feasible to go through the whole list for just one article (for the both of us!), so I cherry-picked a few warnings both from the General and the Optimization section.

The first warning from the top V512Â is a warning code related to memory buffer filling. The class bFile is part of the Bullet serialization system which is used to save/load bullet objects. Look at the snippet below:

The defineÂ B3_SIZEOFBLENDERHEADERÂ is set to 12 but if you look carefully at the m_headerString char array definition youâ€™ll notice that itâ€™s only 7 bytes long. The function memcpyÂ atÂ line 7Â is copying/reading 12 bytes out of a 7 bytes array. Needless to say that this is a bug and the consequences of this type of errors are either buffer overflows and dirty data reads. It would have been worse if m_headerStringÂ was part of a struct where the allocated memory for it is contiguous. For instance:

What do you think header will contain after memcpy is executed? For the first 7 bytes it will contain 0s, but for the other 5 bytes will contain 1s!

Letâ€™s move on to the second warning from the list. CodeÂ V773Â is a memory leak warning. Personally I think memory leak bugs are the worst kind, especially forÂ game development. This issue was spotted in the Bullet OpenCL module.Â OpenCLÂ (Open Computing Language) isÂ a framework based on the C99Â language and similar to CUDA thatÂ provides a standard interface forÂ parallel computing. This module is still experimental in Bullet and itâ€™s used to run the physics simulation off the GPU.

In the b3openclutils.cpp file,Â pointer srcFileHandle is assigned twice. PVS-Studio is telling us that assigning twice the same pointer without releasing the memory couldÂ lead to a memory leak.

LookingÂ carefully at the code above,Â it can beÂ noticed that in total srcFileHandle is not assigned twice, but six times!Â The first time itâ€™s assigned atÂ line 682, if the handle is invalid then the pointer is assigned again within the loop (lines 687-692) for max 5 attempts (i < 5). Before starting panicking and coming to any conclusion letâ€™s analyze the CreateFileA function and what it does. CreateFileA is a typedef for CreateFile, which is a Win32 function toÂ create or open a file or I/O device. When the function is invoked and itÂ succeeds, the return value is an open handle to the specified file. However if the function fails, the return value is INVALID_HANDLE_VALUE. Obviously the handle need not to beÂ closed, i.e. released toÂ free memory. Thus there is no memory leak as long as the function fails. This is in fact a false positive. However if the function were different, and it returned a new pointer all the time it was invoked then the warning would be totally correct.

The second memory leak warning was generated in fileÂ b3gpunarrowphase.cpp. This time the issue is slightly different, there is a pointer that is allocatedÂ within the function and not released before the function exit. After looking carefully at theÂ registerCompoundShapeÂ function I noticed that the pointer is not released at all anywhere within the function or the class.Â  This is a realÂ memory leak bug and PVS-Studio is correct.

The last warning V802Â belongs to the optimization section. I found this type of suggestion extremely interesting and helpful, especially for structsÂ whoseÂ are used in big arrays. The V802 warnings suggests that the size of a structure can be reduced if the fields are arrangedÂ according to their sizes in decreasing order. The struct in question is this one:

This struct represents the soft body contact info and isÂ used to storeÂ the collision response force. Assuming there are at a given timeÂ 10^6 contact points, there would be in memory 32 Megabytes of data only for this struct. Saving 8 bytes for each contact by rearranging the fields as follows:

That rearrangementÂ can save up to 8 Â· 10^6 = 8.000.000 bytes (8 Megabytes). Clearly there might not be a million contacts points withinÂ a simulation but I hope you understand the importance of reducing structure sizeÂ if you intend to useÂ hundred of thousand or even million of instances of a struct.

The aim of this article was to explore the effectiveness of static analysis on a very well established open source library, Bullet Physics.Â Despite I took only aÂ few warnings into account a buffer overflow and a memory leak bug came out.Â Unfortunately it is not possible to eliminate false positives from static analysis, in fact it took me some time to identify the veracityÂ of theÂ warnings. However I am very happy with the outcome and there is a lot more to be done on Bullet Physics, so I cannot wait to have enough material to create a pull request.

Static analysis is certainly a time-consuming task, in particular if done rarely, but it is definitely worth the time. If you stop for a moment to think how muchÂ effort it takes to designÂ and to implementÂ correctly unit andÂ integration tests youâ€™ll realise that it isÂ time-consuming too. This is why a processÂ like TDD isÂ usually adopted from theÂ very early stage. For the same reason static analysis should be part of the software development life cycle from the early stages and also integrated into the build environment.



 A special thanks goes to Andrey Karpov, CTO atÂ â€œProgram Verification Systemsâ€ Co Ltd, for supporting this initiative and the help with PVS-Studio.|||

Introduction Static Analysis vs Dynamic Analysis The Test Bench: Bullet Physics Conclusions Acknowledgments Introduction Hello folks! I'm here again this time toÂ talk about static analysis. If you are a developer with little to noÂ knowledge on the subjectÂ this is the right article for you. Static analysis is the process of analyzing the code of a programâ€¦