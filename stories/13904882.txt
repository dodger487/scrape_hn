This is a long document because it's the only complete documentation for the Surf browser. This is a necessary document because other browsers have become so rickety that Surf has become the go-to browser for anyone willing to use a simple, keyboard-centric interface.

Surf is a simple, lightweight browser from Suckless Tools, the same people who brought you dmenu and dwm. When compiled and configured right, Surf is incredibly robust and stable, able to handle most websites extremely well, and it has a clean and simple layout without buttons and bars to encroach on the web material you're reading. Unfortunately, Surf is underdocumented, so most who try Surf give up after a few minutes, moving on to Firefox or Chromium or Palemoon or Midori. This web page serves as the needed documentation to make Surf a pleasure to work with.

Surf gains a new credibility and significance now (2017), because in 2017, most browsers have declined in stability and performance, over the last several years, to the point where several of them are unusable on various distros. We all know Firefox is now skating on the edge of uselessness, at least on several distros. Palemoon, the "lighter Firefox", has performance problems that frequently drag the whole computer almost to a standstill. Midori, Luakit, Xombrero and most of the other Webkit derived browsers intermittently abort suddenly, at least when hosted on Void Linux. I'm having some success with Chromium, but it's piggy and often quirky. If you're anything like me, these days browsers are exhibiting ever worsening flaws, so that ever more frequently you need to once again switch browsers to one that sucks just a little less than the others.

Meanwhile, over the past few years, the Surf browser has acquired CSS and Javascript abilities, so it now renders as well as, and very similarly to, any of the big boys. And if you run it right, it's stable: More stable than most of the usual suspects: Especially Firefox and Palemoon. So now, with the big boys defaulting on stability and performance, Surf begins to look like the best of the bunch, at least for general purpose browsing.

Of course Surf isn't perfect. I found no obvious way to use SSL with Surf, although the source code appears to have some code related to SSL. Maybe you can get it to work with SSL, but lacking both a URL bar and that cool little lock icon, I wouldn't do online banking, shopping or bill paying with Surf. Because in some environments using Surf with plugins producing the dreaded "program vanished" Webkit bug, many folks can't use Surf with plugins such as ad blockers. Also, the only way to configure Surf is to recompile it, and many folks prefer to use the version installed by their package manager. And typically, the package manager version has small, low contrast fonts used to acquire URLs, requiring modification by anyone with bad vision. And when you modify by recompilation, you'll find that Surf depends on a surprising number of other software you might not have installed.

With no URL field, no button bar, and no back button, Surf isn't mouse-friendly without adding some user addable features discussed toward the end of this document.

This out of the box keyboard-centricity is fine: Keyboard productivity is much higher than mouse productivity. But Surf lacks keyboard-accessibility in one critical browsing activity: Navigating to and following links. So as Surf ships from the factory, you need to keep switching from mouse to keyboard: A guaranteed productivity killer. Surf documents a Javascript implementation of "link hinting": A functionality by which, when invoked, all visible links are numbered and you can follow them by typing in the number. Unfortunately, the javascript solution Suckless Tools gives you works on some web pages and not others. Later in this document you'll be given a 12 line piece of Javascript that makes Surf's Javascript solution work every time. Also given later in this document is a way to make the Grave accent key into the equivalent of a back button, so you can keep mousing with your right hand while easily going back in history with your left.

Surf has no URL field, so neither copying nor pasting the URL is obvious. It does, however, have hotkeys for copying the current URL into the clipboard (Ctrl+y), and navigating to the URL currently in the clipboard (Ctrl+p). Surf doesn't have the handy URL completion that most modern browsers have, and this is the one missing productivity feature you can't make up for with creative configuration.

Surf is very, very different from most browsers. It's an acquired taste, and most of us would prefer Firefox as it existed in 2010, or even Galeon from 2005. But those choices are gone now: Firefox is sand saturated molasses. So is Firefox's "lighter" little brother Palemoon, and when hosting a few tabs with challenging web pages, both give your computer that Windows 95 pacing from the days of the Pentium 1 with 64 MB of RAM. Galeon is gone, and its descendants are part of the Gnome3 universe, with Gnome (along with its FreeDesktop siblings including systemd) becoming more of an "in for a penny, in for a pound" type thing. It's beginning to look like Surf is the last good browser standing.

Yes, most of us would prefer 2010 Firefox, but for the past three or four years a lot of us have been switching browsers often -- every time our favorite one broke. And many of us use different browsers for different things. And I think that's where Surf comes in: A great browser for generic web viewing and Youtube videos. For secure online transactions you'd probably use Firefox (it works OK if used on one website at a time) or Chromium. Or, if yours isn't one of those distros with the webkit arbitrary abort problem, Midori, Luakit, Xombrero or any number of other lightweight browsers work quite well. To reiterate, what separates Surf from the other Webkit driven lightweights is that with Surf you can fix those aborts.

Let me reiterate: Firefox and Chromium work quite well if you use them only for online secure transactions, while offloading generic browsing, and especially videos, to lightweight browsers like Surf. Just don't give heavy work to Chromium, or especially Firefox.

One of the best things about Surf is its simplicity. The C code compiles with a minimum of fuss, and missing dependencies (mostly devel packages) are easy to deduce from compile error messages. If things get squirrelly, you can look at the (easy) source code or change it. Configuration is as simple as changing the config.h file and recompiling.

If you like operating your browser from the keyboard, you're going to love Surf. Almost everything that could be done can be done with hotkeys, and it's quite easy to modify config.h to give yourself new hotkeys.

Another nicety of Surf is an acquired taste: Lacking all buttons and bars, Surf devotes every square millimeter to the content you're viewing. It does this by offloading the functionalities of all those buttons to hotkeys, which usually turns out to be faster than mousing them. Use Surf for a couple weeks, then go back to Firefox, and you'll feel like you're viewing the web through a little peep hole.

This is 2017, we're rapidly getting to the point where browsers are like email clients: They all suck. In this environment, the Surf browser, which sucks a lot less than the rest, takes on a new importance.

Surf is limited to looking at one website at a time, like the browsers from 1996. Don't worry though: With the addition of another Suckless Tools program called Tabbed, you can have the equivalent of a tabbed browser. The command is simple enough:

The following hotkeys then control your tabbing:

As long as we're on the subject of hotkeys, here are a few hotkeys for Surf survival:

Tabbed works well. I promise. You can have all the tabs you want in Surf. Tabs won't be a problem.

But for your own sanity, get Surf running first, learn how to use it, and if you're configuring it, configure it completely. You don't need the distractions of configuring/compiling Tabbed while learning Surf. While you're learning and setting up Surf, please remember there's no shame in running multiple copies of Surf, each tuned to a different website, and using your window manager's Ctrl+Tab to move between them. Soon enough you'll install, set up and use Tabbed to zip between tabs at the speed of light.

Try installing Surf with a package manager. It might suit your needs, and if it does, that will save you a lot of work, because Surf has a lot more dependencies than you might first suspect, and lack of some of those dependencies could cause a runtime mistake (not even error, just malfunction) rather than failure to compile. So just use your package manager's search facility to find the package containing Surf, and use your standard package manager install command to install it. Then run Surf as follows:

Your next step is to operate Surf with its hotkeys.

To kill a single instance of Surf (not run with Tabbed), just use the Window Manager Close Window Command. Beyond that, the following comprise the most widely used Surf hotkeys:

Surf is built more for keyboard use than for the mouse. There's no back button to click. There's no URL field to click and paste into. The person wanting to use a mouse would be much better off with Midori than with the standard default Surf. But if you like productivity, you like the keyboard, and for those who like the keyboard, Surf offers a wealth of keyboard techniques.

Surf offers two very different ways to follow links from the keyboard. One way, link hints, is discussed in its own section later in this document. The other way, using the arrow keys and Enter key, is described in the next couple paragraphs.

The trick is to scroll with Ctrl+j or Ctrl+k till the link you want is approximately on the top or bottom of the viewing area, then use up arrow, down arrow, left and right to move the very thin dashed line to the link you want. Once the link is so surrounded, press Enter and Surf will download the page pointed to by that link. This isn't perfect. The thin dashed line is not visible at a glance: You need to look carefully. And it works only on text links. But in a great many cases, it gets the job done, especially for those with great visual acuity. And remember, you can always get link hints running..

Another productivity enhancer would be some sort of mouse-based "back button", so if you already have the mouse in your right hand, you can quickly use your left hand to tap a left-keyboard key. I personally use the Grave accent ('`'). F2 (GDK_F2) are both excellent for moving to the previous web page. As shipped, Surf already gives you Ctrl+Shift+l for this purpose, but that requires you to drop and later re-grab your mouse. With the Grave Accent, your right hand stays right on the mouse. The grave accent is incredibly easy to hit with the left hand, but it prevents ever typing a grave accent into a text entry field. F2 is harder to hit quickly (and without too much looking), but it's unlikely to conflict with any other situation. F1 is used for "help" in too many places, and Esc has too many other usages to make it practical.

To do this, within config.h, copy the original Ctrl+r hotkey line, and change the copy to either the Grave accent of F2. This document later features a section on modifying the source and recompiling.

No Surf feature is murkier, more poorly documented, and more argued about on the Internet than Link Hints. After reading and following the advice in this section, Link Hints will work perfectly for you every time.

Some folks say Link Hints works. Others say it doesn't work. Still others say it works on some websites and not others. The latter is the accurate assertion, as this section will later demonstrate. But first, the following is an example of how crazy arguments about whether it works or not can get:

There are other web pages with similar back-and-forth arguments, but they're hard to find because Surf is a common word and the Surf browser isn't used by many people. Meanwhile, Suckless Tools' official Link Hints page gives no indication that there's any problem at all:

The section you're now reading settles this once and for all, by giving you a web page http://troubleshooters.com/simple_page.html that doesn't work with Suckless Tools' official Link Hints Javascript code, and giving you a 12 line Javascript addition that causes all web pages, including http://troubleshooters.com/simple_page.html, to work with Link Hints.

Link Hints are numbers that appear beside every link, after you press Ctrl+Shift+f. When you keyboard-input the number corresponding to a link, the web page that link points to is pulled up in a new browser, or if you're using Tabbed, a new tab. This means you can do all link work from the keyboard: A powerful productivity advantage once you get used to it. For the Surf browser, Link Hints are implemented in Javascript you copy into ~/.surf/script.js.

Before doing anything else, back up your existing ~/.surf/script.js, if you have one. This procedure could mess it up, so be ready to put it back.

The people at Suckless Tools have already written (almost) all the Javascript for you. First, navigate to http://surf.suckless.org/files/link_hints. Go down to the section titled "Code". That section contains nothing but the Javascript code to implement Link Hints. Copy that entire block of code to the clipboard.

In ~/.surf/script.js, put about 10 blank lines at the bottom, and below those blank lines , then paste the code you copied below the 10 blank lines, and theoretically you now have Link Hints. Test your new Link Hints on this web page by running the following command at the command prompt:

This web page appears in a new browser. Now press Ctrl+Shift+f and notice that each link (there are several at the top of this web page) gets highlighted and acquires a number. Type in the number for one of the links and notice a new browser appears with that link's web page. You've proven that Surf's Link Hints work!

Now do the same thing, but with a very simple web page:

On this simple web page, press Ctrl+Shift+f, and note that nothing happens. This is discouraging. This is what has created all the arguments, misunderstandings, and storming off the field on the Internet. The Link Hints given by Suckless Tools works for some web pages, and not for others. In fact, Suckless Tools' code works for any page that already has at least one CSS stylesheet, and fails on any web page not containing a CSS stylesheet. Suckless Tools' Javascript inserts CSS rules in Stylesheet 0, whether or not there is a Stylesheet 0, and many simple web pages have no CSS, so they have no Stylesheet 0.

To see the exact location where the existence of at least one stylesheet is assumed and acted upon, see the first lines in functions setHintRules() and deleteHintRules().

So I created some Javascript that adds a Stylesheet if there are no stylesheets. Here's my Javascript:

So, to guarantee Link Hints on all web pages, make ten blank lines below the current bottom of your ~/.surf/script.js file, and copy and paste the preceding code below the ten new blank lines, and save. Now test on a simple page:

Press Ctrl+Shift+f and make sure the preceding page's one link is numbered, and that when you enter the number of that link, a new instance of Surf (or a new tab) appears with Troubleshooters.Com's home page. Troubleshoot as necessary, noticing that for debugging purposes, the preceding website actually has a div with id diag_kludge. Make sure Link Hints still work with more complicated pages.

Ctrl+Shift+f follows a link into a new tab. Sometimes that's what you want, but often it isn't. Pressing Ctrl+Shift+f to follow a series of links leaves you with too many tabs, perhaps dozens. Usually, what you want is to follow the link into its web page in the current tab.

The Link Hints javascript code you copied actually offers such a hotkey: Ctrl+f. Unfortunately, Ctrl+f is already the hotkey for Find in Surf, and it's an excellent hotkey for that: Both mnemonic and commonly used. So you have to change Ctrl+f. I changed it to Ctrl+w just for ergonomic reasons. Change it to any other key combo you want that has no other meaning in Surf or Tabbed, but change it to something, because it's very necessary.

What you just did was, in a paraphrase of Joe Biden, a Big Fantastic Deal! With the addition of surefire keyboard driven Link Hits, use of Surf exclusively through keyboard interaction becomes not only possible but easy and productive.

Scroll then hint, not vice versa! If you scroll after Link Hinting, you'll very likely encounter unnumbered links. But if you scroll to the link you want (quite easy from the keyboard) and then press Ctrl+Shift+f, all links visible on the current screen are visible, and you can enter the desired number.

Ctrl+Shift+f is a toggle! If you're anything like me, your first inclination when trying to turn off Link Hints will be to press the Escape key, but this doesn't work. Turn Link Hints off the same way you turned them off: With Ctrl+Shift+f.

It took me a looooong time to identify the key distinction between websites that did and didn't work with Suckless Tools' Link Hint code (pre-existence of a stylesheet), and because I'm not the world's greatest Javascript guy and Surf isn't the greatest Javascript development environment, a long time to create the workaround. So I stopped before making Link Hints perfect. You can continue the work, and if you find how to improve it, please email me.

By the time you add both Suckless Tools' Link Hints javascript and my guaranteed stylesheet addition, ~/.surf/script.js is a mess. If you've added in your own Javascript, ~/.surf/script.js becomes very hard to maintain. It would be nice if ~/.surf/scrpt.js looked more like the following:

However, I tried the preceding, and it didn't facilitate Link Hints when pressing Ctrl+Shift+f, so I went on to other things and left this as an exercise for the reader.

The current link highlighting often obstructs the text of the link. So you need to toggle Link Hints off, memorize the relevant links, and then toggle Link Hints on. Not good for productivity.

Fixing this would require going into Suckless Tools' javascript code and changing the CSS. Either the original colors must be evaluated to change the text color to a contrast of the new background color, or perhaps leave foreground and background alone except make the text blink. Yeah, this is the first time I've ever recommended blink, but it might make sense in this case.

I can use Link Hints in its current form, just toggling Link Hinting to memorize the relevant link texts. So I leave a more readable solution as an exercise to the reader.

Right now, following a link with Link Hints always brings up a new browser or tab, whereas you might desire following the link in the current browser or tab. Each has its own advantages and best situations. I leave it as an exercise for the reader to implement this as an option.

If you manage to implement solutions for any of these suggested improvements, please email me.

If you can use Surf as it comes from your package manager, by all means do that, because the alternative is downloading and compiling it. Almost all configuration requires recompilation. And compiling Surf requires many more dependencies than you might imagine.

That being said, a few added hotkeys makes Surf much more productive. Also, most packagers assume the world has 20/20 vision, so you might have no choice but to modify it so you can see it. Especially obnoxious is the tendency to make dmenu entries (Surf uses dmenu for all input) tiny-fonted midgray on darkgray. I mean really, couldn't you have set it up white on black or bright green or light yellow on black? Who would it have offended? But noooooo.

So in many cases, you have no choice to compile Surf. Don't worry, it's quite doable.

Download the tarball (link at bottom of http://surf.suckless.org/. Untar the tarball into a directory owned by a non-root user. You'll see several files, including a README file.

Start by reading README, config.mk and config.def.h. Don't change any of them unless you're using BSD or a very bizarre Linux distribution, and not even then. The first time you compile, config.dev.h and config.mk are consulted to create config.h, which in all but the most abnormal cases should be the only file you modify.

As you read config.dev.h, which as you remember you do not modify, you'll see all sorts of boolean properties, a few functions and macros, and down toward the bottom a bunch of hotkeys and a few mouseclick mappings to functions. It's these hotkeys and perhaps mouseclicks that you'll spend the most time with.

Search for the string dmenu, which occurs inside a macro called SETPROP. If, when you press Ctrl+g or Ctrl+f, the text in the input area that opens at the top left of the screen isn't readable enough, you'll later be changing that by adding arguments to dmenu, as later detailed in the Surf Configuration Details section.

The packages you know must be installed to make Surf work are the following:

Surf uses GTK+, so you need all the GTK+ header files, which normally aren't installed. Search your package manager for all packages with string "gtk+" and also containing "devel", for your architecture.

What a mess. There are Webkit + GTK packages, and Webkit2 + GTK, and Webkit + GTK2, and Webkit2 + GTK2. My experience is that if it has the strings "webkit", "gtk" and "devel", and is a package for your architecture (64 bit or 32 bit), you're best off to install it now. If you happen to install an extra one, that's a lot easier than not installing the right one(s) and having to troubleshoot. If really needed, you can delete what you believe to be the extra one(s), one at a time, after it's compiling, and if it continues to compile, I guess it was extra. But if you want to get Surf compiled before New Years, install them all at first.

This is used by the Surf make file to configure certain packages. Even though this package is maintained by Freedesktop.Org, it has almost no dependencies.

Surf compiles without dmenu, but you won't be able to input a URL or search string without it. Install dmenu.

gdb is the Gnu Debugger. Surf runs perfectly without it. Most of the time. But occasionally a challenging website makes it error out with a message about not finding gdb. If you install gdb and gdb-debug, this particular error can't happen.

While compiling and configuring Surf, you'll do many instances of make plus run. And you sure don't want to log in as root and do a make install every time. So create the following shellscript to make and run, in the current directory, as you:

The preceding script assumes your source files are in ~/compiles/surf-0.7, which is the current version on 3/9/2017. If your Surf version is different, modify line 2 accordingly. I called my shellscript jj, because it's very easy to type ./jj over and over again.

Even if you followed every instruction so far in this document, I'm betting your first compile will fail. Something always goes wrong. So just read error messages and keep fixing the problem accordingly. The problem is usually a package that hasn't been installed yet.

After it compiles, it probably won't work right, so you'll need to keep tweaking and compiling it till it does. Just keep compiling again and again until it's perfect. Each compile takes about 3 seconds, so it's no big deal.

Even when it works right, you'll probably want to add some custom hotkeys, and maybe, if your vision is less than that of an eagle, add size and contrast to some fonts, and then recompile. Keep on until it's perfect.

When surf is exactly how you want it, it's time to install it and its man pages in the standard way, which is in /usr/local/bin and /usr/local/man. So perform the following command to do this:

Or, if you have one of those distros that depends on sudo, perform the following:

After you type in the password, Surf will be installed. By the way, Surf has an "uninstall" option for its make, if you ever need to use that.

This section details how you can configure your Surf program to your exact needs. All the work described in this section is performed by editing the config.h file. This section describes the setting of several simple details, and then goes heavily into setting hotkeys, and setting the font size of the dmenu-driven URL input field, via modifications to the dmenu part of the SETPROP() macro.

Open up the config.h file and browse through it. At the top is the user agent string, which is the browser which Surf is masquerading as. This is necessary because sites created with Surf in mind are rare indeed. Even sites created to be browser-agnostic (like the one you're now reading), are fairly rare. After the user agent string comes some strings representing files and directories used by Surf. Then come some booleans affecting how Surf looks and behaves.

Then you come to the first things you're likely to modify: The default font and zoom level. If Surf seems to render fonts and/or images too small for your eyesight, try cranking up the zoomlevel a little bit. If that doesn't work, maybe crank up the default font size just a smidge. Be careful though, if you use big numbers like a 1.8 zoom level or a 22 point font, many sites will render into what looks like a junk heap, so enlarge only as needed.

Next you come to a bunch of mostly booleans determining how webkit acts. For the most part, you'll probably want to leave these alone. Next you come to the SETPROP() macro, which has its own subsection within this section.

Skip on down to the following line:

MODKEY is Surf's foundational modifier key. A modifier key is a keyboard key that modifies rather than printing, such as Ctrl, Alt, or the Windows key. The makers of Surf believed that Ctrl was the best choice for MODKEY, and for the most part I concur, but if you're not using the Windows key for anything else and want to use it for Surf hotkeys, you can do that by changing the preceding line to the following one:

Below the preceding line of code is a comment warning you "If you use anything else but MODKEY and GDK_SHIFT_MASK, don't forget to edit the CLEANMASK() macro." That warning applies to the modifier mask of a hotkey record.

Below the warning is the declaration for an array called keys[], which is an array of a typedef called Key. The following is the definition for Key, as coded in surf.c:

In other words, each Key element in the keys[] array is a struct consisting of:

To summarize the preceding several paragraphs, the definition of a hotkey is an element in the keys[] array consisting of a struct with elements modifier keys, regular key, callback function, and argument. This means you can make your own hotkeys by copying other hotkeys and changing one or more of the four elements. You need to know the GTK symbols for the keyboard keys, and this info can currently (3/2017) be found at https://www.rpi.edu/dept/acm/packages/gtk/1.2.10/gtk+-1.2.10/gdk/gdkkeysyms.h. You'll probably have a local copy of gdkkeysyms.h, findable with the following command:

Here are some hotkeys I added:

In the preceding, #1 goes back to the last viewed page (like a back button) when the user presses F2. #2 does the same thing when the user presses the grave accent (`. Both of these aid the mouse user in doing the back function without dropping the mouse and assuming a full home key typing position. #3 gives Surf the same reload hotkey as Firefox, Chromium, Palemoon and the like. #4 partially replicates the F6 action of major browsers and brings up the URL field. #5 needs a discussion of its own...

Theoretically a tabbed surf session should go to the last argument given to the surf command, as should each newly-invoked tab. Sometimes, when you use the surf-open.sh script from a browser, email client or irc client that doesn't happen just right. Also, sometimes on an already navigated tab you just want to go right to your home page. So you need to define a home page and key combo to make that happen. The key combo is easy: Just place the following line toward the bottom of the rest of your hotkey definitions in Surf's config.h:

The only remaining task is that constant HOMEPAGE is undefined. No problem. Go up in config.h, and just before the definition of SETPROP, insert the following three lines, surrounded on top and on the bottom with blank lines:

Obviously, you'll change the string assigned to HOMEPAGE to the URL of whatever you'd like as your home page.

One more task remains: You really need the go-to-homepage functionality accessible via the mouse too. So, at the bottom of all the mouse click definitions at the bottom of config.h, insert the following:

The preceding makes left Ctrl+leftclick go to the home page. Obviously, you'll change the string assigned to HOMEPAGE to the URL of whatever you'd like as your home page. The following shows it assigned to http://192.168.100.2/littlinks.html. That page is a hierarchy of links that I keep up. Obviously, you'll assign it to the home page of your choice. Insert the following code, surrounded on both ends by a blank line, modified to represent your desired web page, right above the definition of SETPROP:

Now, every time you press Ctrl and then left click on the browser, your desired home page is displayed.

There are certain corner cases, involving variables such as distro, build, webkit build, perhaps which plugins are installed, and which website you're looking at, that can cause Surf to abort with no useful message either in the Surf window or in the terminal from which Surf was invoked. Judging from the fact that Midori, Xombrero and Luakit exhibit this same intermittent problem but Chromium, Palemoon and Firefox do not, I suspect it's a Webkit thing, and only on certain distros (I'm seeing it on Void, but my friends with Devuan don't see it). Luckily, Surf gives you an easy way to work around this corner case problem.

It turns out that if you turn off plugins in Surf, you turn off this corner case problem. This is why, throughout this document, I've recommended using the -p option to Surf: -p turns off plugins. If you find it hard to remember to use this option in every shellscript and every command you type, you have the alternative of turning off plugins in the surf command itself, by making a small change within config.h. Find the following line:

Change the TRUE to FALSE, recompile and reinstall. Now, when you run the surf command, Surf operates with no plugins.

Why, oh why do developers assume the user has 20/20 vision?

Surf uses dmenu to acquire URLs and search screens from the user, and unfortunately, dmenu ships from Suckless Tools with a rather small and thin 10 point non-bold monospace font. It ships with non-contrasty colors: Normal video foreground is #bbbbbb (semi-light gray) on #222222 (very dark gray). The selected video is also less than ideal at #eeeeee on #005577. If you fall short of 20/20, it's hard to see what you're typing or what the default is.

My dmenu comes from the package manager, so I can't change the colors by dmenu compilation. But I can sure change them by dmenu arguments, and that's what I do in the SETPROP() macro. I take the following line:

I strongarmed the colors to high contrast by adding arguments to the dmenu call:

Notice the singlequotes around the argument values. Don't use doublequotes. Don't go entirely without quotes. Use single quotes because that's what works. Now, about the meaning of these options:

You might decide to use one other dmenu option: -fn, the font. It's normally not a good idea to enlarge fonts, but if increased contrast doesn't work, or the fonts are obviously microscopic, you might have to. Occasionally microscopic fonts are due to a delusional developer who thinks the world shares his 20/10 vision, but most of the time they occur due to a "no such font" situation. In these cases, you need to specify the font.

Finding the designation of a workable font can be an exhausting trudge of trial and error through the lands of fonts.alias, xfontsel, and shortcut names like 10x20.

Fortunately, there's a reliable designation that works with whatever fonts you happen to have installed on your computer. It consists of a family designation that is either "sans", "serif" or "monospace", followed optionally by one or more key/value pairs describing the font appearance. The following is a comically large example:

In the preceding command, first notice the fact that all characters are lower class. Keep everything lowerclass in the -fn specification. It's true that you can sometimes get away with uppercase letters in the values of some of the key/value pairs, but those cases aren't determinate or logical or easy to describe. Keeping everything lowercase keeps everything working. And remember, the font family designation must always be one of the following three:

The following is a practical line for the dmenu command within Surf:

click here to see the entire line.

Referring to the preceding command, if you wanted to make it bold without changing the size, simply remove :size=14 from the string. In other words, remove one colon and the size specification. Making fonts bigger often causes geometric problems, but making fonts bold, which usually helps readability immensely, has very little downside.

Install the Tabbed package from your package manager. Now run each of the following commands:

The preceding are the two different ways to run Surf from Tabbed. The first way has no home page, so that every new tab is a blank web page. The second way opens every new tab to a specific web page: Most likely an HTML list of your favorite links. Each way has pros and cons.

Method #2 is a big productivity boost if you have an excellent HTML links page maintained up to date. Method #1 enables you to use the Ctrl+T key combo to open a new tab and specify its URL in one step, and also, #1's command syntax is much easier to remember and more explainable. So choose one of the two methods and run Surf under Tabbed. A list of Tabbed hotkeys follows:

Spend some time operating Surf through Tabbed. See how you like it. Notice that if you're running without a home page, when you use Ctrl+T, you can just type in your new URL and press Enter, and the new tab will show that URL's page. Make sure to use the Ctrl+T tab picklist several times, and decide whether its font and contrast are appropriate for you. If not, you'll need to modify Tabbed, a subject covered later in this document. Look at the thin black strip above the content and below the titlebar (if you have a titlebar) and note the font and contrast of writing on it. Is that writing legible enough not to slow you down? If not, you'll need to modfy Tabbed.

There's a whole section on modifying Tabbed, but first let's look at the command used to run Surf under Tabbed...

The command to run Surf under Tabbed without a home page is as follows:

In the preceding -p is necessary in order to prevent plugins. In some situations (such as my Void Linux installation), running Surf with plugins allowed sooner or later results in the dread Webkit "quick vanish" problem. The e in -pe means "parent this Surf to the window ID after the e. Of course, there's no window ID after the e, so the plot thickens. The deal is, Tabbed places the window ID at the end of the entire command, so things work out. But if you try to add a home page using the following command, it gripes about not being able to find a web page with a long numeric URL:

The preceding throws an error resembling "Problem occurred while loading the URL http://134217731/". That number (and your number will be different and may change from time to time) is the window ID. The explanation is that the tabbed command bolted the window ID at the end of the surf command. Having the window ID at the end of the command causes failure because, when using the -e option, surf uses its very last argument as the website to look up, but Tabbed appends the window ID at the end.

What you really need is the following:

But you can't do that because you don't know the window ID ahead of time. Right? Well, it turns out you can do that, though indirectly. Read the part of the Tabbed man page dealing with the -r option...

The -r option specifies the number of the argument of the surf command to replace with the window number. Notice I said the number of the argument of the surf command, not the number of the argument of the Tabbed command. The reason the man page uses the word "command" instead of "surf" is that Tabbed works with several other programs to give them tabs. Just keep in mind that a Tabbed command generically looks like the following:

The -r option for tabbed refers to the argument of <command>

Remember, what you need is the equivalent of:

To achieve that aim, do the following:

The preceding puts the letter "x" as a placeholder for the window ID, and then uses the tabbed -r option to specify that Surf's arg 2 gets replaced with the window ID. Well, Surf's arg2 is the "x" placeholder. Try it: It works.

To modify Tabbed, you need to download its source tarball (.tgz) file, untar, modify its config.h, and compile. Here's a good compile/run script to use until you get it just right:

Repeatedly modify config.h and run the preceding shellscript until Tabbed works just how you want, then perform the following:

Or if you're on one of those distros that depends on sudo,

The preceding paragraphs covered the compile part of modifying Tabbed. Now for the questions "how" and "why?" From my perspective, the hotkeys of Tabbed are good and useful, so the only reason I'd want to modify the default is fonts and colors. Tabbed writes in two places:

If the dmenu picklist isn't readable enough for you, perform the same steps on it that you did when the dmenu URL acquirer field with the SETPROP() macro.

I find Tabbed's as-shipped colors for the tab strip unfortunate. When seeing what tab you're on, or what tab you want to move to, the difference between current and other tabs must be obvious at a glance. As shipped from Suckless Tools, the current tab is #ffffff on #555555, and the non-current tabs at #cccccc on #222222. This is not glanceable, and in fact these two gray-on-grays aren't even easy to read, let alone glance. And the tiny font is reedy -- it would be much better if it were bold. I'm not going to tell you what colors to use, but if you want to gain the full utility of tabs, change the colors so the text is readable and it's obvious at a glance which tab is current. If you want to follow my advice and make the tabs font bold, perform the following:

As it ships from the factory, Surf is more mouse-friendly than you'd initially imagine. Obviously, you can click on links, just like any other browser. You can turn the mouse wheel to scroll a little, or you can drag the scrollbar to scroll a lot. Right clicking on a web page's background brings up a menu from which you can go back (like a backbutton), go forward, or reload the page. If your mouse has buttons 8 and 9, then button 8 is already configured to go back (like a backbutton) and button 9 is configured to go forward. If you're using Tabbed, the mouse wheel on the thin black horizontal tab menu cycles through your tabs. You can also left click on a specific tab in the tab menu to choose that tab. Middle-clicking on the text of a tab closes that tab. Here's a summary:

About the only common browser functionalities not included in the preceding list are opening a new tab and acquiring a new URL (like Ctrl+g). You can add those functionalities if you want. Once you add them, the only thing you'll need the keyboard for is typing in a URL, and that's something that's never going to be done efficiently with a mouse.

In the Surf window itself, as opposed to the Tabbed strip, you want the mouse's center button to acquire a URL and display that page, exactly like Ctrl+g does. It seems easy enough to do within config.h, by adding the following mouse button record at the bottom of all the other mouse button records defining the buttons[] array:

The ClkDoc means "clicked anywhere on the document. It would override middle click of a link if it were above the line specifying middle click in a link, but because it's lower down in the buttons[] array, and the array is looped through top to bottom, middle button on a link does what's specified for middle click on a link. When adding keystrokes and/or mouse strokes, always be careful about order, because both are read and executed in order.

The good news is, the preceding addition enables the middle mouse button on an unpopulated area of the browser window to perform the "acquire URL and go there" functionality. The bad news is that unless you've already used Ctrl+g to do that on this particular window, it acquires the URL but doesn't go there, and if you're watching the stdout on the terminal from which you ran Surf, you'll see an error saying "xprop: error: Invalid window id format: _SURF_URI." So the user must do a per-tab intervention to make the middle mouse button acquire and go. That's inexcusable.

Given that the window id format is wrong only before acquire and go have been used successfully, it seems likely to be a window id initialization problem. Looking at all the functions in surf.c, just by name function updatewinid() seemed likely to be involved. Searching all occurrences of updatewinid() revealed that updatewinid() is called from the kepress() function, but not by its mouse counterpart, buttonrelease(). Indeed, commenting out updatewinid() within keypress() created the exact same error on pressing Ctrl+g. The updatewinid() function occurs just before the for loop in keypress(), so I put one just above the for loop in buttonrelease(), and bang, the problem went away.

So to complete your installation of middle mouse button bringing up acquire and goto URL, place the following line immediately above the for statement in function buttonrelease:

So, placing one line in config.h and one in surf.c adds the functionality.

One more thing. I've never maintained this code, and I'm not as good a developer as the person who does, but I have a strong hunch that leaving out the updatewinid() in function buttonrelease() was an oversight, given the design resemblance of updatewinid() to keypress(). However, it's also possible that my insertion of the call to updatewinid() could cause side effects, perhaps even a security flaw. You need to ask more knowledgeable people than me about that.

Add the following code to the bottom of the mouse action list:

The preceding makes left Ctrl+leftclick go to the home page, just as soon as you define the constant HOMEPAGE. Do that by adding the following code, surrounded on both sides by a blank line, above the current definition of SETPROP:

To complete your mouse-centric functionality, you need to be able to create new tabs with the mouse. You'll enable a right mouse click anywhere on the Tab strip to create a new tab. You'll do this in tabbed.c, not in its config.h include file.

Edit tabbed.c search for function buttonpress(), and look for its for loop. Within the for loop is an if statement, which itself contains a switch statement. The switch statements has cases for buttons 1, 2, 4 and 5. The right mouse button is button 3, so go ahead and add its case between the cases for buttons 2 and 4, as follows:

Recompile and enjoy your new right click on tab strip creates new tab feature.

My advice to edit tabbed.c goes against the Suckless Tools philosophy, which maintainst that all user changes should happen in the config.h file. But in this case, the only way to do it is in the tabbed.c file, because unlike the Surf source code, Tabbed doesn't maintain an array of possible mouse events in its config.h, but instead hard codes responses to mouse events within tabbed.c.

The guys from Suckless Tools are quite clever. In the Surf distribution, they give you a shellscript called surf-open.sh which your email and IRC clients and other programs can call just the same way they call Firefox or Chromium, and if Tabbed is running, the desired website becomes one more tab. If Tabbed isn't yet running, surf-open.sh starts Tabbed with a tab showing the requested URL. Behold the power of minimalism: They've built Tabbed and Surf as tiny tools that do one thing and do it well, so that with their 32 line shellscript surf-open.sh Surf can act like the bigshot browsers.

Running make install doesn't automatically put surf-open.sh on your path, so you need to copy it to a location on your path.

The final step is to tell your other programs to use surf-open.sh as your browser.

Clicking a URL in an email or IRC post and having it show up in the one and only Tabbed program might not be your cup of tea, especially if you make heavy use of workspaces. Sometimes you don't want to hunt for your browser: You want it to pop right up, even if it's a separate window adding to the mess. If this paragraph describes you, then instead of using surf-open.sh for the application's browser, use surf -p.

The preceding article showcases one of the Suckless Tools advantages: The fact that a mere mortal can actually change it. Now I'm not average: I spent 15 years as a professional developer, ten of which I spent doing C. So I can read well written code, and I used that ability to look over the less than 4000 lines of Surf plus Tabbed code to figure out what to do. Now imagine me doing the same thing on Firefox. Or Libreoffice. Or systemd. I'd spend a half hour scanning the more than a hundred thousand lines of code, give up in frustration, and either use something from Suckless Tools or write my own.

Suckless Tools makes their software short, simple, organized, and well commented. Suckless Tools programs have no runtime config files. Instead, ordinary config changes can be done by non-programmers in the config.h program, using the well laid out comments and matrix like arrays of structs, and then compiled. Even fixing flaws in their program or adding features not anticipated (like right click makes new tab) are quite doable by someone who knows a little C, because in almost every case you can compare and contrast similar code (such as keypress() vs buttonrelease() or making a copy of an existing mouse event array element and changing its button and callback function and args). The folks at Suckless Tools have written their software to be modified by mere mere mortals, and they've succeeded mightily.

An often stated benefit of Free Software is if you don't like it, you can change it. Of course, this is usually propaganda. I don't like systemd, but I don't have the tech chops to modify udev to not depend on systemd. Both udev and systemd are maintained by paid teams, not by one guy, as far as I know. But with Suckless Tools software, one guy really can change them.

And speaking of systemd, did you know that Suckless Tools offers Suckless Init, an 83 lines of C program that acts as PID1 and can be combined with daemontools-encore to make a complete init system that yes, a mere mortal can understand? They created dmenu, the greatest small software component ever produced: You can use it to acquire choices and text throughout all your software and shellscripts.

From Suckless Tools, you can get a lightweight terminal called st, a lightweight but supposedly efficient shell called mksh, a reliable screen locker called slock, a complete tiled window manager called dwm, assembled from Suckless Tools and other simple software, a Plan 9 toolset called 9base, and lots more. If you're a DIY software person who likes bolting software together, Suckless Tools is a treasure trove.

It's no accident that the Suckless Tools project has created arguably the most stable and productive browser. The Suckless Tools project operates according to a philosophy that almost guarantees minimal bugs, minimal unexpected behavior, minimal negative interaction with other software, and maximum ability to mix and match its tools into the system of your choice, as long as stability and performance are prioritized above "pretty."

For starters, Suckless Tools programs are kept short. Surf's source code is less than 2000 lines, assuming you're not counting the code within Webkit and GTK. The Tabbed program has less than 1500 lines of source. The dmenu program has less than 1300 lines. The three of them fit together to make a tabbed browser with user input acquisition and a menu of tabs provided by dmenu. Both Tabbed and dmenu are designed from the bottom up to be generic tools.

For instance, Tabbed can be used to provide tabs for non-tabbed programs. Ever want a tabbed version of xterm? The following command gives it to you:

I never before used urxvt because of its lack of tabs and tiny fonts. The following solves both problems:

The dmenu program is known far and wide as the ultimate GUI picklist and input field tool, easily used with lots of other programs. It's also a trivial way for you to acquire user input in your programs and shellscripts. Many people use it hundreds of times daily to run programs. Dmenu is the great window manager equalizer, rendering the window manager's menu and other program running features moot. If you need to write a quick and dirty application, dmenu is your friend. You can integrate dmenu with any software that can receive input from a shellscript.

Complexity reduction is a top priority with Suckless Tools. The Suckless Tools project realizes that complexity is costly, in terms of providing nooks and crannies for bugs to hide, in terms of difficulty making changes, in terms of understanding how the program works, and in terms of performance.

A part of complexity reduction is keeping dependencies to a minimum. In this Freedesktop.Org, Redhat, Systemd "age of integration", an age in which the word "encapsulation" has been forgotten, it's a pleasure to work with small executables with thin interfaces that can be assembled into any software you desire, at the shellscript level, via those thin interfaces.

There was a time when Linux was, by necessity, DIY. As time went on, it became ever less so, opening Linux to a wider and wider audience. But from my viewing angle, the march away from DIY went too far. Browser are now feature-packed, or, as I view it, feature-encumbered, so today they're slow, crashy, and always surprising. OS level user interfaces like KDE, Gnome and Unity constantly get in the way, often perceptibly slowing fast machines, and making moderate machines crawl. Now the Xfce desktop environment is following in their footsteps. Gnome now cares what init system you use: Modern Gnome runs only on computers initted with systemd. Huh? Six or seven years ago the Kmail email client got so complex as to be almost unuseable. Now Thunderbird can take hours to sync up with an IMAP server on the same computer.

Much of this bloatware is created by tight compile-time binding with many libraries, via thick and complex interfaces. If one of the libraries gets a bug, the software using it becomes buggy too. Good software gone bad: Who hasn't experienced switching from one to another to another and back again in a category of software, as various programs stop doing what's needed or start acting erratic?

And then there are the "great new ideas" from the developers, each one requiring you to substantially alter your work flow, which is pretty funny, considering that your original workflow was probably modeled to accommodate your workarounds for applications that were procedurally or ergonomically inefficient. Some free software library developer decides it would improve his career to re-code his creation in Newfad.js plus Object Haskell, and now you need to change your work habits and even your shellscripts.

DIY stands for Do It Yourself. The alternative to DIY is HIDTY: Have It Done To You. With HIDTY, some developer makes a decision or mistake, and you have to adapt your habits, or perhaps go searching for different software. It happens over and over again. HIDTY is the way of life of the Windows user. Over the years, HIDTY has presented us with ever more complex software on Linux.

Till recently, HIDTY has been the exclusive trend on Linux. Those with mental blocks against shellscripting and simple Pythoning had no choice but HIDTY, and even programmers went with HIDTY with explanations like "I don't have time to program my machine." But lately, HIDTY fiascos like Kmail2 and systemd have caused those with programming chops to change that mantra to "I don't have time to adapt to every experiment these devels decide to do." In the past three to five years, more than a few computer users have gone DIY, opting for simple software that does one thing and does it well, freeing them from playing catch-up with the latest version of bloatware.

And more and more, this new group of DIY computer users is discovering Suckless Tools.

I doubt anybody envisions Surf when discussing browsers. But as you get used to it, you appreciate it. You appreciate its productive keyboard interface. For me, Surf started out as a refuge to the problems I was having with Firefox, Palemoon and Chromium. Surf meant settling for less than my ideal just to get stability and performance. But as I got used to it, I began to appreciate its efficient use of screen real estate and its stability, even on crazy sites. I appreciate its keyboard-centricity, without giving up efficient mousery. I appreciate the superb way it handles Youtube videos. And finally, I fell in love with the way I can program it with whatever features I want.

When you switch to Surf, be aware that you can't truly evaluate it until you've been using it as your primary browser for a week. And even then, you can't really evaluate it unless you've configured it to meet your needs.

In the last few years, mainstream browsers have declined in performance and stability to the point where people are willing to sacrifice features for stability and performance, bringing a new relevance to the Surf browser from Suckless Tools. Surf devotes all its screen real estate to the web page under examination. Surf is remarkably well suited to control via the keyboard. This document has shown you how to compile your own Surf in order to have a user interface that exactly matches your way of working. In the hands of someone unafraid of changing a little C code, Surf is a browser custom made to you. This has been a very long document because this document is the most complete documentation of Surf on the planet. Bookmark this document.

If you've been falling out of love with Firefox, Chromium, Palemoon, Qupzilla and the crew, you owe it to yourself to investigate Surf. If you've begun feeling uneasy with big software that frequently stops working, be sure to investigate Suckless Tools.|||

Using the surf browser.