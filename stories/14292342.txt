ES6 modules are now supported in Chrome Canaryâ€Šâ€”â€Šyouâ€™ll have to enable the Experimental Web Platform flag in . Chrome now joins many other modern browsers which also include support behind flags. ğŸš©

Modules are an important part of building any web application which comprises more than trivial script. The JavaScript community has developed impressive workaroundsâ€Šâ€”â€Šread all about their history in a 2012 post by @addyosmaniâ€” but thereâ€™s huge benefit in using the platform itself.

Modules must be eventually included in your HTML with , which can appear as an inline or external script tag. See the example â€”

For more technical reading on ES6 Modules, see Ponyfoo or Jakeâ€™s blog.

The most interesting part of ES6 modules is that they are only supported by modern, â€˜evergreenâ€™ browsers. Their release represents a seachange in they way we build and release JavaScript.

Legacy browsers that do not support ES6 modules will ignore module code, and only load tags with an empty type or .

This is an amazing ğŸŒŠ water markâ€” if you ship code via ES6 modules, you can use modern JavaScript features without compiling, or polyfillsâ€Šâ€”â€Šboth which can slow down modern browsers or result in larger binary sizes.

And thatâ€™s hugeâ€Šâ€”â€Šnot just to speed up your development process ğŸ› ï¸, but also for your growing set of users who can support ES6 modules. ğŸ‰

As of writing, only Safari has shipped support for ES6 modules. By the time you read this, the other major browsers might have released the feature publicly â€”Edge, Firefox and Chrome (as titled!) are all behind flags.

If you ship ES6 modules today, thereâ€™s no downsideâ€” you wonâ€™t affect legacy browsersâ€Šâ€”â€Šand only those users on supported browsers (or perhaps for developers, testing with the flag enabled) will benefit.

Create a projectâ€Šâ€”â€Šwith a clear entry point, that will be included by your HTMLâ€Šâ€”â€Šthat uses and to place your code into modules.

For browsers that support ES6 modules, youâ€™re done. This will also shorten your development cycleâ€Šâ€”â€Šyouâ€™ll literally not have to compile at all to test changes in any JavaScript, just reload and go.

Rollup wonâ€™t transpile away new JavaScript features for very old, ES5-only browsers. It does nothing with ES6â€Šâ€”â€Šignoring , Â , etc.

(Next, youâ€™ll need to pass your code to Babel, Traceur, or Googleâ€™s Closure Compiler to do the remaining ES6 â†’ ES5 compile stepsâ€” see Google for moreâ€Šâ€”â€Šthis is pretty well documented, but out of scope of this post).

Once youâ€™ve rolled up your ES6 and transpiled it to ES5, ship it as normal, but add the attribute. This lets modern browsers know to ignore this codeâ€Šâ€”â€Šit will never even be fetched from the network.

âš ï¸ Thereâ€™s one caveatâ€Šâ€”â€ŠSafari 10.1 & Mobile Safari 10.3 donâ€™t understand , although itâ€™s fixed for its next release. Include this snippet in a regular tag before using .

As a browser parses your ES6 module code, it will discover a tree of dependencies that it needs to fetch in order to execute your code.

As only knows about , it will have to fetch it completely before fetching and â€Šâ€”â€Šand so on. This can cause a number of requests, measurable as â€˜request chainsâ€™ â€”

Whatâ€™s the solution? Instead of sending many files in production, you can just use Rollup to generate a single, modern ES6 fileâ€Šâ€”â€Šand serve that via Â .

This might seem counter-intuitive ğŸ¤”â€Šâ€”â€ŠIâ€™m removing ES6 modules but still shipping as a module? But remember that support for â€œES6 modulesâ€ can be used as just a high water markâ€Šâ€”â€Šâ€œES6 modulesâ€ gives you the confidence, and the mechanism, to send modern JavaScript to your clients.

If youâ€™re building ES6 modules, you wonâ€™t be able to import any code that isnâ€™t written in ES6 module formatâ€Šâ€”â€Šyouâ€™ll experience all side effects of code you importâ€Šâ€”â€Šbut e.g. from commonJS isnâ€™t somehow magically converted to . ğŸ©

ES6 modules are therefore great for projects you mostly control, but could be a challenge if youâ€™re depending on the wider ecosystem at largeâ€Šâ€”â€Šunless the project you depend on exports itself using the platform syntax.

Modern JavaScript features are great, and can increase your productivityâ€Šâ€”â€ŠI personally canâ€™t wait to write only and when I work with promisesÂ , for exampleâ€” and Iâ€™m so excited to actually ship that ES6 code to modern browsers (while still having a sensible answer for legacy browsers).

I hope this article has given you a push to go forward and update your toolchainâ€Šâ€”â€Šor given you thoughts for your next project. #UseThePlatform

Please leave comments, queries and insights on Mediumâ€Šâ€”â€Šor find me on Twitter. Thanks for reading! ğŸ•µï¸|||

ES6 modules are now supported in Chrome Canary â€” youâ€™ll have to enable the Experimental Web Platform flag in chrome:flags. Chrome now joins many other modern browsers which also include supportâ€¦